 SUBROUTINE ZHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC )
 DOUBLE PRECISION ALPHA , BETA
 INTEGER K , LDA , LDC , N
 CHARACTER TRANS , UPLO
 COMPLEX * 16 A ( LDA , * ) , C ( LDC , * )
 LOGICAL LSAME
 EXTERNAL LSAME
 EXTERNAL XERBLA
 INTRINSIC DBLE , DCMPLX , DCONJG , MAX
 COMPLEX * 16 TEMP
 DOUBLE PRECISION RTEMP
 INTEGER I , INFO , J , L , NROWA
 LOGICAL UPPER
 DOUBLE PRECISION ONE , ZERO


 ONE = 1.0D+0
 ZERO = 0.0D+0

 IF ( LSAME ( TRANS , 'N' ) ) THEN
 NROWA = N
 ELSE
 NROWA = K
 END
 UPPER = LSAME ( UPLO , 'U' )
 INFO = 0
 IF ( ( .NOT. UPPER ) .AND. ( .NOT. LSAME ( UPLO , 'L' ) ) ) THEN
 INFO = 1
 ELSE IF ( ( .NOT. LSAME ( TRANS , 'N' ) ) .AND. ( .NOT. LSAME ( TRANS , 'C' ) ) ) THEN
 INFO = 2
 ELSE IF ( N .LT. 0 ) THEN
 INFO = 3
 ELSE IF ( K .LT. 0 ) THEN
 INFO = 4
 ELSE IF ( LDA .LT. MAX ( 1 , NROWA ) ) THEN
 INFO = 7
 ELSE IF ( LDC .LT. MAX ( 1 , N ) ) THEN
 INFO = 10
 END
 IF ( INFO .NE. 0 ) THEN
 CALL XERBLA ( 'ZHERK ' , INFO )
 RETURN
 END
 IF ( ( N .EQ. 0 ) .OR. ( ( ( ALPHA .EQ. ZERO ) .OR. ( K .EQ. 0 ) ) .AND. ( BETA .EQ. ONE ) ) ) RETURN
 IF ( ALPHA .EQ. ZERO ) THEN
 IF ( UPPER ) THEN
 IF ( BETA .EQ. ZERO ) THEN
 DO J = 1 , N
 DO I = 1 , J
 C ( I , J ) = ZERO
 end

 end

 ELSE
 DO J = 1 , N
 DO I = 1 , J - 1
 C ( I , J ) = BETA * C ( I , J )
 end

 C ( J , J ) = BETA * DBLE ( C ( J , J ) )
 end

 END
 ELSE
 IF ( BETA .EQ. ZERO ) THEN
 DO J = 1 , N
 DO I = J , N
 C ( I , J ) = ZERO
 end

 end

 ELSE
 DO J = 1 , N
 C ( J , J ) = BETA * DBLE ( C ( J , J ) )
 DO I = J + 1 , N
 C ( I , J ) = BETA * C ( I , J )
 end

 end

 END
 END
 RETURN
 END
 IF ( LSAME ( TRANS , 'N' ) ) THEN
 IF ( UPPER ) THEN
 DO J = 1 , N
 IF ( BETA .EQ. ZERO ) THEN
 DO I = 1 , J
 C ( I , J ) = ZERO
 end

 ELSE IF ( BETA .NE. ONE ) THEN
 DO I = 1 , J - 1
 C ( I , J ) = BETA * C ( I , J )
 end

 C ( J , J ) = BETA * DBLE ( C ( J , J ) )
 ELSE
 C ( J , J ) = DBLE ( C ( J , J ) )
 END
 DO L = 1 , K
 IF ( A ( J , L ) .NE. DCMPLX ( ZERO ) ) THEN
 TEMP = ALPHA * DCONJG ( A ( J , L ) )
 DO I = 1 , J - 1
 C ( I , J ) = C ( I , J ) + TEMP * A ( I , L )
 end

 C ( J , J ) = DBLE ( C ( J , J ) ) + DBLE ( TEMP * A ( I , L ) )
 END
 end

 end

 ELSE
 DO J = 1 , N
 IF ( BETA .EQ. ZERO ) THEN
 DO I = J , N
 C ( I , J ) = ZERO
 end

 ELSE IF ( BETA .NE. ONE ) THEN
 C ( J , J ) = BETA * DBLE ( C ( J , J ) )
 DO I = J + 1 , N
 C ( I , J ) = BETA * C ( I , J )
 end

 ELSE
 C ( J , J ) = DBLE ( C ( J , J ) )
 END
 DO L = 1 , K
 IF ( A ( J , L ) .NE. DCMPLX ( ZERO ) ) THEN
 TEMP = ALPHA * DCONJG ( A ( J , L ) )
 C ( J , J ) = DBLE ( C ( J , J ) ) + DBLE ( TEMP * A ( J , L ) )
 DO I = J + 1 , N
 C ( I , J ) = C ( I , J ) + TEMP * A ( I , L )
 end

 END
 end

 end

 END
 ELSE
 IF ( UPPER ) THEN
 DO J = 1 , N
 DO I = 1 , J - 1
 TEMP = ZERO
 DO L = 1 , K
 TEMP = TEMP + DCONJG ( A ( L , I ) ) * A ( L , J )
 end

 IF ( BETA .EQ. ZERO ) THEN
 C ( I , J ) = ALPHA * TEMP
 ELSE
 C ( I , J ) = ALPHA * TEMP + BETA * C ( I , J )
 END
 end

 RTEMP = ZERO
 DO L = 1 , K
 RTEMP = RTEMP + DCONJG ( A ( L , J ) ) * A ( L , J )
 end

 IF ( BETA .EQ. ZERO ) THEN
 C ( J , J ) = ALPHA * RTEMP
 ELSE
 C ( J , J ) = ALPHA * RTEMP + BETA * DBLE ( C ( J , J ) )
 END
 end

 ELSE
 DO J = 1 , N
 RTEMP = ZERO
 DO L = 1 , K
 RTEMP = RTEMP + DCONJG ( A ( L , J ) ) * A ( L , J )
 end

 IF ( BETA .EQ. ZERO ) THEN
 C ( J , J ) = ALPHA * RTEMP
 ELSE
 C ( J , J ) = ALPHA * RTEMP + BETA * DBLE ( C ( J , J ) )
 END
 DO I = J + 1 , N
 TEMP = ZERO
 DO L = 1 , K
 TEMP = TEMP + DCONJG ( A ( L , I ) ) * A ( L , J )
 end

 IF ( BETA .EQ. ZERO ) THEN
 C ( I , J ) = ALPHA * TEMP
 ELSE
 C ( I , J ) = ALPHA * TEMP + BETA * C ( I , J )
 END
 end

 end

 END
 END
 RETURN
 END
