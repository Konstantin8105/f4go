
             INFORMATION ABOUT UPDATING PANDA2, BOSOR4, etc.
             ARCHIVING THE UPDATED PANDA2, BOSOR4, etc, PRODUCING
             COMPRESSED "TAR" FILE OF THE ARCHIVE,
             ftp-ing THE "TAR" FILE TO A CUSTOMER,
             RECONSTRUCTING THE PANDA2, BOSOR4, etc, DIRECTORY STRUCTURE,
             AND INITIALIZING IN PREPARATION FOR RUNS.

   (NOTE: This file was originally written with PANDA2 in mind. Therefore
          most of the examples involve PANDA2. However, the same
          instructions apply to BOSOR4, BOSOR5, and other programs by
          Bushnell).
=======================================================================

PART 1:  HOW TO UPDATE PANDA2, BOSOR4, etc.:

If you have instructions for updating a source file, here is how you
proceed (example is for PANDA2, but BOSOR4, BOSOR5, etc. are analogous):

0. Log on to the platform for which you are making the update
   (see Part V).

1. Update the source file in the directory ~username/panda2/source
according to the instructions.

2. Go to the directory ~username/panda2/execute

3. Type the command:

    make -f makefile.<machine>

in which <machine> is sun4, sgi, dec, rs6k, hp700, etc., depending 
on which computer you have PANDA2 running on.

If, for example, you made a compilation of the PANDA2 mainprocessor
on the sun4 and it was successful, you should have a new executable

       main.sun4*

in the ~username/panda2/execute directory. Look at the top of the
listing you get from "dir" to make sure that this file is listed
and that its date is current.

If you have any problems, please call

Dr. David Bushnell
Dept. 93-30/Bldg. 251
Lockheed Palo Alto Research Labs
3251 Hanover St.
Palo Alto, CA 94304
USA

telephone: (415) 424-3237
fax:       (415) 354-5489
e-mail:    bush@trinity.rdd.lmsc.lockheed.com
-----------------------------------------------------------------------------

PART II: ARCHIVING THE UPDATED PANDA2, BOSOR4, etc.

1. Go to a suitable temporary (working space) directory. As of this
writing, I use ~bush/temp  .

2. type the command

      build_archive

3. answer the questions interactively. As of now the directory name
asked for by "build_archive" is ~bushnell  .

4. "build_archive" asks which program should be archived. Provide all
responses in lower case. Do not separate names with commas; use spaces.
------------------------------------------------------------------------------

PART III: PRODUCING A COMPRESSED "tar" file of archived programs

1. type the command

    tar cvf - `'ls'` | compress > panda2.sun4.tar.Z

------------------------------------------------------------------------------

PART IV:  make a tape or ftp the "tar" file to a customer

Make a tape:

On SGI cricket:

1. Log on to cricket (bush,<usual>1)
2. cd to directory where compressed tar file resides. (You cannot use the
   "squiggle" on cricket, so you have to type /usr5/bush/temp4, not just
    ~bush/temp4).
3. insert cartridge (typical: 3M D8-112 8mm data tape) in the upper left
   slot (drive) of CRIMSON box in the room next to terminal room. (you
   do this by pushing the button and waiting patiently for the little door
   to open, then insert the tape, bullnose forward, then close door gently)
4. return next door to the terminal room and type the command:
    tar cvf /dev/mt/tps1d5.8500 panda2.sgi.tar.Z
5. to test (read) the tape:
   (a) cd to home directory where you want to put the file from the tape.
   (b) type the command:
       tar xf /dev/mt/tps1d5.8500
   (c) wait patiently; when cursor reappears, do ls -al to see if file
       is there.

On the VAX:

1. Log on to VAX in the VAX room in Building 201 (>>connect rddvax, etc.)
2. Set default (dsk16:[bushnell.dsk6.GENOPT] , for example)
3. Degauss tape (get Brian Craig to help: x 45221)
4. Physically mount tape on drive (Get Brian Craig, x 45221 to help, because
                                   the 8mm drives are in a restricted area)
5. Give the following commands:
   INIT/DENS=6250  <tapedrive>  <label>   (This erases the tape. Typical
                                           names: <tapedrive> =$4$MUA0:
                                                  <label> = GENOPT )    

   MOUNT/FOR  <tapedrive>    (typical name for tape drive is $4$MUA0:)
   SET DEFAULT DSK16:[BUSHNELL.DSK6.GENOPT]        (for example)
   BACKUP/LOG *.*;*  <tapedrive> <label>.BCK
    (for entire directory tree: BACKUP/LOG [...]*.*;* <tapedrive> <label>.BCK)

6. Read the tape to test it. (This is just reading the titles of the files
   that are on the tape, not actually copying the files from the tape to
   a directory):
   MOUNT/FOR <tapedrive>
   BACKUP/LIST <tapedrive>

7. To write from the tape to a directory:
   MOUNT/FOR <tapedrive>
   SET DEFAULT DSK16:[BUSHNELL.DSK6.<name>]  (<name> = some temporary location)
   BACKUP/LOG <tapedrive> *.* *

8. To write two savesets on a single tape (PANDA2 and BOSOR4 were done this
   way for Lockheed Fort Worth Co. on 5/24/95. An 8mm tape was used.

   INIT/DENS=6250 $4$MUA0: PANDA2
   MOUNT/FOR $4$MUA0:
   SET DEFAULT DSK16:[BUSHNELL.DSK6.PANDA2]
   BACKUP/LOG/IGNORE=(LABEL) *.*;* $4$MUA0:PANDA2.BCK
   SET DEFAULT DSK16:[BUSHNELL.DSK6.BOSOR4]
   BACKUP/LOG/IGNORE=(LABEL) *.*;* $4$MUA0:BOSOR4.BCK

To ftp:

1. You have to be on trinity to ftp outside Lockheed.

   cd ~bush/temp

2. Log on to the machine to which you intend to ftp the "tar" file:

       ftp <hostname>

        (login to the machine to which you intend to ftp the "tar" file.)
         NOTE: anonymous ftp works as follows:
               username: anonymous
               password: bush@trinity.rdd.lmsc.lockheed.com     )

3. Still in "ftp mode", go to directory that is to receive the "tar" file:

       cd <directory>

4. Still in the "ftp mode" get in the "binary" mode by typing the command

       binary

5. Still in the "ftp mode", type the command

       put panda2.sun4.tar.Z

This will take some time, perhaps an hour or more.


6. Compare the length of the ftp transmission with the
size of the directory at the "home" location (~bush/temp).  
The lengths should be the same.  (Sometimes long ftp's get screwed up). 

7. Often it is a good idea to ftp to
       hitchhiker.space.lockheed.com/pub/incoming
   Then a customer can pick up the panda2.sun4.tar.Z file from there.
   This way, you avoid having to send a tape, which is a pain.
   This is done as follows:
         rlogin trinity
         cd ~bush/temp
         ftp hitchhiker.space.lockheed.com
         user: anonymous
         pass: bush@trinity.rdd.lmsc.lockheed.com
         cd pub/incoming
         binary
         put panda2.sun4.tar.Z
         dir panda2.sun4.tar.Z
         bye
   The customer can pick up the file panda2.sun4.tar.Z by doing the
   same, except instead of "put" he types "get". He should be at the
   directory which he wants to be the PARENT of BOSOR4, BOSOR5, PANDA2, etc.
   when he "gets" the compressed tar file.

8. Erase all files from the temporary (working space) directory, using
the command

      'rm' -rf *

Make sure you do this only from ~bush/temp  .  Otherwise, you will lose
everything.

8. Some additional notes:

Sometimes a customer's requirements necessitate the splitting of the
compressed tar file into smaller packets before ftp transmission. The
following will accomplish this (I have not yet tried it, but this
command list was suggested by Luke Kramer of Grumman on 10/6/94):

 uuencode panda2.sgi.tar.Z panda2.sgi.tar.Z > panda2.sgi.tar.A 
                                                (binary to ASCII conversion)
 wc -l panda2.sgi.tar.A                         (get total line count)
 split -nnnn panda2.sgi.tar.A panda2.sgi.tar.A  (split panda2.sgi.tar.A
                                                 into packets each with
                                                 nnnn lines. A good idea is
                                                 to use nnnn = total/10).
Now do the "ftp":
 rlogin trinity
 cd ~bush/temp
 ftp gdstech.grumman.com
 user: anonymous
 pass: bush@trinity.rdd.lmsc.lockheed.com
 prompt                                        (turn off mput prompt for
                                                the next file).
 mput panda2.sgi.tar.A??
 ls -l
 bye
 
After successful transfer, the customer regenerates the original
compressed tar file panda2.sgi.tar.Z by means of the following commands:

 cat panda2.sgi.tar.A?? > panda2.sgi.tar.A
 uudecode panda2.sgi.tar.A

------------------------------------------------------------------------

PART V: DETAILS ABOUT UPDATING ON VARIOUS MACHINES AT LOCKHEED

1. Updating the source code on all machines:

        cd ~bushnell/panda2/sources
        copy <library name>.src  <library name>.old
        ftp univrs
        (login to univrs, giving username and password)
        cd [bushnell.dsk6.panda2]
        get <library name>.src
        bye
        
2. Compiling on the sun4:

        rlogin pauling (or other sun4, but use Jeanne Gee's sun4 for now)
        cd ~bushnell/panda2/execute
        nice make -f makefile.sun4 |& tee makesun4.log

     NOTE: Often makefile.sun4 doesn't work because space runs out
           on the "tmp" disk during compilation of struct. If this
           happens, type instead of "make -f makefile.sun4" the command
               
             make -f makefile.suntemp

           This new makefile sets up temporary storage in

             /usr5/bush/f77test

           instead of on the "tmp" disk associated with pauling.


2b. Compiling on sun/sparc with Solaris operating system:

      rlogin trinity (only trinity works: "STRUCT" gives memory problems
                      on other Solaris machines at LMSC)

      cd ~bushnell/panda2/execute
      nice make -f makefile.sol |& tee makesol.log

3. Compiling on the hp700:

        rlogin sherwood.is -l bushnell
        cd panda2/execute
        nice make -f makefile.hp700 |& tee makehp700.log
           (use "nice" because there is a lot of network transfer;
            pipe diagnostics to the file makehp700.log.)

4. Compiling on the sgi:

        get an account from brian
        rlogin fermi
        cd ~bushnell/panda2/execute
        nice make -f makefile.sgi |& tee makesgi.log

5. Compiling on the rs6k:

        rlogin lobo.is -l bushnell
        cd panda2/execute
        nice make -f makefile.rs6k |& tee makers6k.log

6. Compiling on the dec:

        rlogin aml_12    ("aml_12" is Curt Peterson's DEC3100)
        cd ~bushnell/panda2/execute
        make -f makefile.dec
========================================================================

PART VI
HOW TO RESTRUCTURE DIRECTORIES AT THE USER'S FACILITY (INSTALL)

1. Go to the directory which you want to be the PARENT of that
   where you want PANDA2, BOSOR4, etc. to reside. If you
   have a tape, copy the file panda2.<machine>.tar.Z from the tape
   to a file with the same name. This is a compressed tar file.
   The argument <machine> of the file name stands for the platform
   (sun4, sgi, dec, hp700, rs6k, etc).

-----------------------------------------------------------------------
   How to read tape:
   (a) go to directory where you want the compressed tar file to reside,
       usually, this will be the PARENT of that where you want PANDA2,
       BOSOR4, etc. to reside.
   (b) insert the tape in the tape drive.
   (c) type ONE of the commands listed next:
        tar xf /dev/mt/tps1d5.8500  (tps1d5.8500 is name used at lockheed)
        tar xv                      (used for default drive)
-----------------------------------------------------------------------

2. With a *.tar.Z file (that is, a compressed tar file transferred
   via ftp or copied from a tape:
        uncompress *.tar.Z   (for example: uncompress panda2.sgi.tar.Z)
        tar xvf    *.tar     (for example: tar xvf    panda2.sgi.tar)

3. Check to make sure that you have the program "install" and that "install"
   is executable.  If it is not, then give the command "chmod 700 install"

4. Execute "install":     install
   and follow the directions that appear at the end of the output
   NOTE: There are some systems that use the word "install" for special
   purposes. You may have to give the command (..path to PANDA2's version
   of install)/install
========================================================================

PART VII
HOW TO RUN

1. All users of BOSOR4, BOSOR5, PANDA2, GENOPT, etc. must run the shell
program called "initialize", which is located in the bin/ directory,
before running any of the programs. They must run "initialize" by 
"source-ing" the file so that the environment variables "initialize"
initializes exist in the user's top-level environment:

        source (..path to bin/...)/bin/initialize

Do "pwd" to find the path to bin/.

NOTE: There are two /bin directories, one in the parent directory to
/panda2 and one in the /panda2 directory. The "bin" that is wanted here
is the one in the parent directory to /panda2.

ANOTHER NOTE: If customer users are on ksh (korn shell) rather than
csh (C shell), then before "source" you must type

       /bin/csh
==========================================================================

PART VIII
HOW TO RUN WITH DEBUGGER ON (THIS SAMPLE IS FOR HP700)

1. Set up a script for "pandaopt" for debugging. We call it in this
   case "pandaxdb" and it is located in .../panda2/bin
   (.../panda2/bin/pandaxdb.com is the file name).

2. When you want to run the panda2 mainprocessor in the debug mode,
   do the following:
 
      alias pandaxdb /users/bushnell/panda2/bin/pandaxdb.com
      pandaxdb
        (answer questions interactively: 1. case name;
                                         2. run in Foreground)
        (pandaxdb will end, leaving you back in the working directory,
          in this case with the prompt:
             bushnell@sherwood: /users/bushnell/panda2/work  )

    Next, type:

      xdb /users/bushnell/panda2/execute/main.hp700

    debugger will print a bunch of stuff, the last line of which is:
         "main.f: main: 189: No Source" in this particular case.
    and on the next line will give a prompt sign, in this case: >  .

    Next you start giving the debug commands. First, set up the first
    breakpoint (usually a procedure name). For example, the command
    in this case might be:

       b struct

    After you start the run (see next command), the program will run
    until it gets to the first call to "struct", then it will stop at
    the first executable line in "struct", printing a line such as: 
            "1: count:   1  Active    struct: 245: No Source"
    This opaque stuff means "break at line 245 in struct".

    Next, you give the run command.  Assume the case name is "casename".
    When you see the " > " prompt, you respond as follows:

        run casename < casename.OPT

    The program reads in the input data from the file casename.OPT.
    and then stops at the first executable line of struct, again giving
    you the prompt. 

    You can continue giving the debugger commands. Particularly helpful
    ones (this is on the hp700, remember!) are as follows:

        help   (gets help topics)
        run casename < casename.OPT       (start the run)
        b [name] (break at first executable statement in proc. "name")
        s      (step forward one step, entering any procedure)
        bx     (set breakpoint at the end of the current procedure)
        c      (continue the run, stopping at the next breakpoint)
        g +5   (go forward five lines)
        trace  (get a traceback).
        p [variable]  (print the value of "variable")
        lb     (list all active breakpoints)
        db [number]  (delete breakpoint "number")

    A typical sequence of commands that you might give follows:

        help
        b struct
        c (or "run casename < casename.OPT if no "run" command has been
           given by you previously)
        g +10
        p varname
        s
        p varname
        s
        p varname
        bx
        c
        s
        lb 
        db 5
        db 6
========================================================================

        
PART IX  Stuff that may be required for porting PANDA2 to DEC-ALPHA running
         VMS operating system



10 June, 1995

To users of David Bushnell's codes on DEC ALPHA with VMS operating
system.

As of this date, the only user that has attempted to get any of
Dave Bushnell's codes (for example, BOSOR4) running on a DEC ALPHA
with VMS operating system is

   Mr. Hansjoerg Buechler
   Sulzer Pumps Ltd.
   Kost 0400
   8401 Winterthur
   SWITZERLAND
   tel: +41 52 262 8556
   fax: +41 52 262 0040
  email:(X.400) C=CH,A=ARCOM,P=SULZER,S=BUECHLER,G=HANSJOERG

Mr. Buechler had difficulty with the block IO MACRO called BLIOMF.MAR,
which works on VAX-VMS but not on DEC ALPHA VMS. In a Fax message to
me dated 25 May, 1995, Mr. Buechler asked me exactly what does BLIOMF.MAR
do and is there a FORTRAN equivalent of it. My reply to him follows:

-------------------------------------------


31 May, 1995

Dear Hansjorg Buchler:

This is in reply to your fax message dated 25 May, 1995, in which you
inquired about the BOSOR4 routine BLIOMF.MAR.

I'm afraid I know very little about BLIOMF.MAR .  Many, many years ago
(about 1980) I obtained this macro from a fellow who needed efficient
block i/o from core to random access storage on VAX/VMS. As far as I
know, there never was a FORTRAN version of BLIOMF.

Enclosed are several lists of routines that have to do with transferring
data from core to random access storage and back, both in fortran and in
c .  Perhaps from a study of these you can figure out how to get BOSOR4
running efficiently on the DEC ALPHA with the VMS operating system.

In particular, I suggest that you compare the lists gaspold.new and
gasp.new. If I am not mistaken (and I may well be!) gasp.new provides the
fortran equivalents of the routines BIOMFO, BIOMFW, BIOMFR, BIOMFC, which
are entry points in BLIOMF.MAR, as you can see from the enclosed list
of BLIOMF.MAR.

Sorry I'm so ignorant of this aspect of my codes.  When it comes to behavior
of thin shells I'm of much more help than when it comes to computer science
type questions.  In developing my programs I beg, borrow, and steal the
computer science stuff that I need. However, I know very little about just
how it works.

If you have any further questions, please let me know.

Sincerely,
David Bushnell
fax: 415-354-5489
tel: 415-424-3237
email: bush@trinity.rdd.lmsc.lockheed.com
-----------------------------------------------------------------

I sent lists of the following routines to Mr. Buechler.

-----------
gasp.new:
-----------

C
C=DECK      GASPNEWLIB
C
C  THIS IS THE GASP LIBRARY THAT IS PORTABLE TO OTHER OPERATING
C  SYSTEMS THAN VAX VMS. IT IS SLOWER THAN THE VERSION CALLED
C  GASPOLD.OLD, WHICH IS WRITTEN EXPRESSLY FOR VAX VMS.
C
C
C
C=DECK      ABORT
      SUBROUTINE ABORT(II)
C
C     THIS ROUTINE EFFECTS AN EXIT FOR THE CURRENT EXECUTION
C     OF THE PROGRAM VIA A CALL TO  E X I T   OR TO A SYSTEM
C     ERROR TERMINATION TRANSFER POINT
C     01 JULY 1976 VERSION
C
      I=0
      GO TO (10,20,30), II
10    CALL ERREX
20    GO TO(10,30),I
30    RETURN
      END
C
C
C
C=DECK      F77BIO
C
C      This collection of "pure" Fortran 77 subroutines simulate the
C      machine  dependent block I/O calls that BOSOR4 expects from
C      GASP
C
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C     Open file
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C
      subroutine  BIOMFO  ( IU, NAME, IOPEN, IERR )
C
      character  NAME*(*)
C
      if ( IOPEN .ne. 2 )  then
        open ( unit=IU, file=NAME, form='unformatted',
     *         access='direct', status='unknown', recl=512,
     *         iostat=IERR )
       else
        open ( unit=IU, file=NAME, form='unformatted',
     *         access='direct', status='scratch', recl=512,
     *         iostat=IERR )
       end if
C
      return
      end
C
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C     Read from file
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C
      subroutine  BIOMFR  ( IU, A, NBYTES, NBLOCK, IERR )
C
      dimension  A(1)
      character  ekey*4
C
      n = IOMRDA ( IU, A, NBYTES/4, NBLOCK-1, 128, nwx, ekey, IERR )
      if ( IERR .ne. 0 ) then
         print *,' BIOMFR: nwx , ekey = ', nwx,ekey
      end if
C
      return
      end
C
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C     Write to file
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C
      subroutine  BIOMFW  ( IU, A, NBYTES, NBLOCK, IERR )
C
      dimension  A(1)
      character  ekey*4
C
      n = IOMWDA ( IU, A, NBYTES/4, NBLOCK-1, 128, nwx, ekey, IERR )
      if ( IERR .ne. 0 ) then
         print *,' BIOMFW: nwx, ekey, n = ', nwx,ekey,n
         print *,' BIOMFW: NBYTES, NBLOCK =', NBYTES, NBLOCK
         print *,' A array =',(A(i),i=1,NBYTES/4)
      end if
C
      return
      end
C
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C     Close file
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C
      subroutine  BIOMFC  ( IU, IERR )
C
      close ( unit=IU, iostat=IERR )
C
      return
      end
C
C
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C     F77 simulation of block I/O routines
C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
C
C
C
C
C=DECK      IOMRDA
C=PURPOSE Read FRU-spanning record from DA Fortran file
C=AUTHOR C. A. Felippa, January 1980
C=VERSION June 1982
C=KEYWORDS auxiliary storage manager input output I/O
C=KEYWORDS data management database DMS DBMS
C=BLOCK USAGE
C
C       NEWFRU =  IOMRDA  (LU, A, NW, IFRU, FRU, NWX, EKEY, IOST)
C
C     Input arguments:
C
C       LU          Fortran logical unit number.
C       A           Array that will receive record.
C       NW          Number of words to read.
C       IFRU        First source FRU (counting from 0).
C       FRU         FRU size in words.
C
C     Output arguments:
C
C       NWX         Number of words transferred.
C       EKEY        4-letter error information key.
C       IOST        Receives I/O status code returned by Fortran
C                   I/O library in case of error.
C
C     Function return:
C
C       IOMRDA      If no abnormal condition detected, returns
C                   next FRU to read/write (a positive integer).
C                   If error detected, returns -1.
C
C=END USAGE
C=BLOCK FORTRAN
      integer function IOMRDA
     $    (lu, a, nw, ifru, fru, nwx, ekey, iost)
C
C                   T Y P E   &   D I M E N S I O N
C
      integer       fru, lu, nw, ifru, nwx, iost, a(*)
      character*4   ekey
      integer       j, kr, kx, n, size
C
C                   L O G I C
C
      kr =       ifru
      size =     nw
      kx =       0
      nwx =      0
      ekey =     ' '
C
 2000   IOMRDA =   kr
        kr =       kr + 1
        n =        min0(size,fru)
        if (n .le. 0)                       return
        read (unit=lu,rec=kr,iostat=iost,err=8000) (a(kx+j),j=1,n)
        kx =       kx + n
        nwx =      kx
        size =     size - n
        go to 2000
C
 8000 IOMRDA = -1
      ekey =     'MIRE'
      if (iost .lt. 0)                      ekey = 'RBEI'
      return
      end
C=END FORTRAN
C
C
C
C=DECK      IOMWDA
C=PURPOSE Write FRU-spanning record on DA Fortran file
C=AUTHOR C. A. Felippa, January 1980
C=VERSION June 1982
C=KEYWORDS auxiliary storage manager input output I/O
C=KEYWORDS data management database DMS DBMS
C=BLOCK USAGE
C
C       NEWFRU =  IOMWDA  (LU, A, NW, IFRU, FRU, NWX, EKEY, IOST)
C
C     Input arguments:
C
C       LU          Fortran logical unit number.
C       A           Array to transmit.
C       NW          Number of words to write.
C       IFRU        First receiving FRU (counting from 0).
C       FRU         Fortran record unit size in words.
C
C     Output arguments:
C
C       NWX         Number of words transmitted.
C       EKEY        4-letter error information key.
C       IOST        Receives I/O status code returned by Fortran
C                   I/O library in case of error.
C
C     Function return:
C
C       IOMWDA      If no abnormal condition detected, returns
C                   next FRU to read/write (a positive integer).
C                   -10    If I/O error detected.
C
C=END USAGE
C=BLOCK FORTRAN
      integer function IOMWDA
     $    (lu, a, nw, ifru, fru, nwx, ekey, iost)
C
C                   T Y P E   &   D I M E N S I O N
C
      integer       fru, lu, nw, ifru, nwx, iost, a(*)
      character*4   ekey
      integer       j, kr, kx, n, size
C
C                   L O G I C
C
      kr =       ifru
      size =     nw
      kx =       0
      ekey =     ' '
C
 2000   IOMWDA =   kr
        kr =       kr + 1
        n =        min0(size,fru)
        if (n .le. 0)                      return
        write (unit=lu,rec=kr,iostat=iost,err=8000) (a(kx+j),j=1,n)
        kx =       kx + n
        nwx =      kx
        size =     size - n
        go to 2000
C
 8000 IOMWDA = -1
      ekey =    'MIWE'
      return
      end
C=END FORTRAN
C
C
C
C=DECK      GASP
      SUBROUTINE GASP
     1(A, NW, IC, ID)
C
c
c                       D I M E N S I O N
c
      DIMENSION A(1)
      INTEGER A
      INTEGER ddpars(4),lsect
      DOUBLE PRECISION WTRANS
      COMMON/IDHIGH/IDMAX
c
c                          D A T A
c
      DATA  ldi /8/, ddpars /4*0/
      DATA  IBLANK /4H    /
      DATA IBUG /0/
C     DATA FIL /4HDIS /
c
c
c                           L O G I C
c
      NOT = 6
      IF (IC.EQ.-1)               GO TO 1000
      IF (IC.EQ.-2)               GO TO 2000
      GO TO 10
c
c.... Initialization (Set sector pointer and declare file)
c
 1000 NWA=1
      IBLOCK=IDMAX+1
      IU=11
      NSECT=512
      IOPEN=-1
      WTRANS=0.
      CALL BIOMFO (IU,'FOR011 ',IOPEN,IERR)
      IF (IERR.NE.0) GO TO 820
      RETURN
c
   10 IF (IC.EQ.3)                GO TO 30
      IF (IC.NE.1)   CALL ABORT
c
c.... Write A to disc
c
      IF (ID.GT.0)                GO TO 20
c
c.... New record
c
      ID=IBLOCK
      NBYTES=4*NW
      IBLOCK=IBLOCK+(NBYTES-1)/NSECT+1
      IDMAX = IBLOCK
      CALL BIOMFW (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 840
      ISTOR = (IBLOCK-1)*(NSECT/4)
      IF (IBLOCK.GE.0) GO TO 20
C     PRINT 900,  nlim * lsect
  900 FORMAT (/35H >> ERROR >> IN GASP:  DISC LIMIT =i10,10H EXCEEDED./)
      CALL  ABORT
c
   20 NBYTES=4*NW
      CALL BIOMFW (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 860
      IF (IBUG.EQ.1) WRITE (6,925) ID,NW,A(NW),IC
  925 FORMAT ( 5H ID= , I10, 6H  NW= , I6, 8H  CHECK= , I14, 4H IC= ,I3)
      GO TO 50
c
c.... Read A from disc
c
   30 NBYTES=4*NW
      CALL BIOMFR (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 880
      IF (IBUG.EQ.1) WRITE (6,925) ID,NW,A(NW),IC
CUPD  OCT26,81
   50 WTRANS=WTRANS+NW
CEND  OCT26,81
      IGAS = IGAS + 1
      RETURN
c
c.... Finalization (list statistics and close file)
 2000 CALL BIOMFC (IU,IERR)
      IF (IERR.NE.0) GO TO 890
      RETURN
  820 CONTINUE
      WRITE (NOT,920) IU,'FOR011.DAT',IOPEN,IERR
  920 FORMAT (/ ' ERROR OPENING FILE.  IU   NAME   IOPEN  IERR '
     $ / 20X I4, A10 , I8, I4)
      CALL ABORT
  840 CONTINUE
      WRITE (NOT,940) IU,NW,IC,ID,IERR
  940 FORMAT (/' ERROR IN BLOCKIO.  IU    NW    IC    ID   IERR '
     $ / 22X 3I6, I8,I6)
      CALL ABORT
      STOP
  860 GO TO 840
  880 GO TO 840
  890 GO TO 840
      END
C
C
C
C=DECK      IB
      FUNCTION IB(N)
C
C     M = N
      IB= N
      IF (N.LE.0) IB = 1
CD     TYPE *,'IB ENTERED',M,N
      RETURN
      END
------------------------------------------------



gaspold.new:
-------------------------------

C=DECK      GASPOLD LIBRARY
C
C  THIS VERSION OF GASP IS GOOD FOR VAX VMS AND RUNS
C  FASTER THAN GASP.NEW, WHICH WILL RUN ON UNIX.
C
C
C=DECK      GASP
      SUBROUTINE  GASP
     1(A, NW, IC, ID)
C
c
c                       D I M E N S I O N
c
      DIMENSION A(1)
      INTEGER A
      INTEGER ddpars(4),lsect
      DOUBLE PRECISION WTRANS
      COMMON/IDHIGH/IDMAX
c
c                          D A T A
c
      DATA  ldi /8/, ddpars /4*0/
      DATA  IBLANK /4H    /
      DATA IBUG /0/
C     DATA FIL /4HDIS /
c
c
c                           L O G I C
c
      NOT = 6
      IF (IC.EQ.-1)               GO TO 1000
      IF (IC.EQ.-2)               GO TO 2000
      GO TO 10
c
c.... Initialization (Set sector pointer and declare file)
c
 1000 NWA=1
      IBLOCK=IDMAX+1
      IU=11
      NSECT=512
      IOPEN=-1
      WTRANS=0.
      CALL BIOMFO (IU,'FOR011 ',IOPEN,IERR)
      IF (IERR.NE.0) GO TO 820
      RETURN
c
   10 CONTINUE
      IF (NW.EQ.0) RETURN
      IF (IC.EQ.3)                GO TO 30
      IF (IC.NE.1)   CALL ABORT
c
c.... Write A to disc
c
      IF (ID.GT.0)                GO TO 20
c
c.... New record
c
      ID=IBLOCK
      NBYTES=4*NW
      IBLOCK=IBLOCK+(NBYTES-1)/NSECT+1
      IDMAX = IBLOCK
      CALL BIOMFW (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 840
      ISTOR = (IBLOCK-1)*(NSECT/4)
      IF (IBLOCK.GE.0) GO TO 20
C     PRINT 900,  nlim * lsect
  900 FORMAT (/35H >> ERROR >> IN GASP:  DISC LIMIT =i10,10H EXCEEDED./)
      CALL  ABORT
c
   20 NBYTES=4*NW
      CALL BIOMFW (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 860
      IF (IBUG.EQ.1) WRITE (6,925) ID,NW,A(NW),IC
  925 FORMAT ( 5H ID= , Z10, 6H  NW= , I6, 8H  CHECK= , I14, 4H IC= ,I3)
      GO TO 50
c
c.... Read A from disc
c
   30 NBYTES=4*NW
      CALL BIOMFR (IU,A,NBYTES,ID,IERR)
      IF (IERR.NE.0) GO TO 880
      IF (IBUG.EQ.1) WRITE (6,925) ID,NW,A(NW),IC
CUPD  OCT26,81
   50 WTRANS=WTRANS+NW
CEND  OCT26,81
      IGAS = IGAS + 1
      RETURN
c
c.... Finalization (list statistics and close file)
 2000 CALL BIOMFC (IU,IERR)
      IF (IERR.NE.0) GO TO 890
      RETURN
  820 CONTINUE
      WRITE (NOT,920) IU,'FOR011.DAT',IOPEN,IERR
  920 FORMAT (/ ' ERROR OPENING FILE.  IU   NAME   IOPEN  IERR '
     $ / 20X I4, A10 , I8, I4)
      CALL ABORT
  840 CONTINUE
      WRITE (NOT,940) IU,NW,IC,ID,IERR
  940 FORMAT (/' ERROR IN BLOCKIO.  IU    NW    IC    ID   IERR '
     $ / 22X 3I6, I8,I6)
      CALL ABORT
      STOP
  860 GO TO 840
  880 GO TO 840
  890 GO TO 840
      END
C
C
C
C=DECK      ABORT
C./	 ADD   NAME=ANGLE
      SUBROUTINE ABORT(II)
C
C     THIS ROUTINE EFFECTS AN EXIT FOR THE CURRENT EXECUTION
C     OF THE PROGRAM VIA A CALL TO  E X I T   OR TO A SYSTEM
C     ERROR TERMINATION TRANSFER POINT
C     01 JULY 1976 VERSION
C
      I=0
      GO TO (10,20,30), II
   10 CALL ERREX
   20 GO TO(10,30),I
   30 RETURN
      END
C
C
C
C=DECK      IB
	FUNCTION IB(N)
C
C       M = N
	IB = N
	IF (N.LE.0) IB=1
C       TYPE *,'IB ENTERED',M,N
	RETURN
	END
-------------------------------------------------



BLIOMF.MAR:
-----------------------

;=DECK      BLIOMF.MAR  LIBRARY
;
;  THIS VERSION OF BLIOMF.MAR IS GOOD FOR VAX VMS AND MIGHT RUN;
;  FASTER THAN THE GASP CURRENTLY INSTALLED IN BOSOR4.
;
;
	.TITLE	BLIOMF
	.IDENT	/BLIOMF/
;
;*********************************************************************
;
;
;   BLOCK - IO ROUTINES
;
;   READ/WRITE IN BLOCK MODE WITHOUT BUFFER
;
;   MULTIFILE VERSION.
;   1 TO 11 FILES MAY BE OPEN SIMULTANEOUSLY. FILES ARE IDENTIFIED BY
;   THEIR LOGICAL UNIT NUMBER IU (IU=1,2,...,11). NOTE THAT IU IS
;   INDEPENDENT FROM FORTRAN AND OTHER LOGICAL UNIT NUMBERS.
;
;   HARDWARE :  VAX-11
;   SOFTWARE :  VMS  VAX-RMS
;
;   S. MERAZZI  30-OCT-80
;
;
;*********************************************************************
;
;   VARIABLE DATA
;
ALQIN=64					;INIT. BLOCK ALLOCATION
DEQIN=64					;BLOCK INCREMENT
;
;   INITIALIZE DATA
;
	.PSECT	BLIOD1,LONG
STRING:	.BLKB		40
IU:	.ADDRESS	0
MAXLEN:	.ADDRESS	65024
MAXBLO:	.ADDRESS	127
LEN:	.ADDRESS	0
BLANK:	.ASCII		/    /
;
FABAD:	.LONG		0
	.LONG		FAB1
	.LONG		FAB2
	.LONG		FAB3
	.LONG		FAB4
	.LONG		FAB5
	.LONG		FAB6
	.LONG		FAB7
	.LONG		FAB8
	.LONG		FAB9
	.LONG		FAB10
	.LONG		FAB11
RABAD:	.LONG		0
	.LONG		RAB1
	.LONG		RAB2
	.LONG		RAB3
	.LONG		RAB4
	.LONG		RAB5
	.LONG		RAB6
	.LONG		RAB7
	.LONG		RAB8
	.LONG		RAB9
	.LONG		RAB10
	.LONG		RAB11
;
FAB1:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB2:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB3:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB4:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB5:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB6:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB7:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB8:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB9:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB10:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
FAB11:	$FAB	ALQ=ALQIN,DEQ=DEQIN,FAC=<BIO,GET,PUT,UPD>,FOP=CBT,-
		ORG=SEQ,RFM=FIX,MRS=512,RAT=<BLK>
;
RAB1:	$RAB	FAB=FAB1,ROP=<BIO>
RAB2:	$RAB	FAB=FAB2,ROP=<BIO>
RAB3:	$RAB	FAB=FAB3,ROP=<BIO>
RAB4:	$RAB	FAB=FAB4,ROP=<BIO>
RAB5:	$RAB	FAB=FAB5,ROP=<BIO>
RAB6:	$RAB	FAB=FAB6,ROP=<BIO>
RAB7:	$RAB	FAB=FAB7,ROP=<BIO>
RAB8:	$RAB	FAB=FAB8,ROP=<BIO>
RAB9:	$RAB	FAB=FAB9,ROP=<BIO>
RAB10:	$RAB	FAB=FAB10,ROP=<BIO>
RAB11:	$RAB	FAB=FAB11,ROP=<BIO>
;
;***********************************************************************
;
;
;
;   SUBROUTINE BIOMFO(IU,NAME,IOPEN,IERR)
;
;   OPEN LOGICAL UNIT IU
;
;   IU   - LOGICAL UNIT NUMBER (1-11)
;   NAM  - FILE NAME (40 CHARACTERS MAX.)
;          MAY BE CHARACTER*X (X <= 40 CHAR.)
;          OR BYTE(X) (X<=39, WITH AT LEAST ONE TRAILING BLANK BYTE)
;   IOPEN- OPEN CODE
;          =  2 OPEN SCRATCH FILE (FILE IS DELETED UPON CALL TO BIOMFC)
;          =  1 OPEN NEW FILE
;          =  0 OPEN OLD FILE
;          = -1 OPEN OLD FILE IF EXISTING,OTHERWISE OPEN NEW FILE
;   IERR - ERROR CODE =0 SUCCESSFUL COMPLETION
;                     =1 WRONG UNIT NO.
;                     =2 FILE NAME ERROR
;                     =3 OPEN OLD FILE FAILED
;                     =4 OPEN NEW FILE FAILED
;                     =5 COULD NOT CONNECT FILE
;
;
;***********************************************************************
;
	.PSECT	BIOCO,NOWRT
;
	.ENTRY	BIOMFO,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	MOVL	8(AP),R0		;(FILE NAME) IN R0
	MOVL	@12(AP),R9		;IOPEN IN R9
	CLRL	R10			;CLEAR ERROR REG.
;
;   DECODE FILENAME
;
	MOVL	#STRING,R3		;PUT (STRING) INTO R3
	MOVL	R0,R2			;SAVE R0 TEMP.
	MOVL	#40,R1			;MAX. 40 CHARS.
	MOVW	(R0)+,LEN		;CHECK IF CHAR-VAR OR BYTE-VAR
	CMPB	(R0),#14
	BEQL	CSTR
	JMP	BSTR
;   CHARACTER*X NAME
CSTR:	CMPL	LEN,R1			;ALLOW 40 CHAR.
	BLEQ	CSTR1
	MOVL	R1,LEN
	INCL	R10
	INCL	R10
	JMP	OPE4
CSTR1:	TSTW	(R0)+
	MOVL	(R0),R2
	MOVC3	LEN,(R2),(R3)
	JMP	OPE0
;   DECODE BYTE-TYPE STRING
BSTR:	MOVL	R2,R0			;RESTORE R0
	CLRL	R4			;R4 IS BYTE COUNTER
	MOVB	BLANK,R2		;TERM. BYTE IN R2
BSTR1:	CMPB	(R0),R2			;TEST FOR BLANK BYTE
	BEQL	BSTR2
	MOVB	(R0)+,(R3)+		;PUT BYTE INTO STRING
	INCL	R4
	CMPB	R4,R1			;CHECK LENGTH
	BNEQ	BSTR1
	INCL	R10			;ERROR, STRING TOO LONG
	INCL	R10
	JMP	OPE4
BSTR2:	MOVL	R10,@16(AP)
	MOVL	R4,LEN
;
;   OPEN FILE
;
OPE0:	
	TSTL	R9
	BGTR	OPE2			;OPEN NEW FILE IF IOPEN=1,2
	JSB	UNIT
	BLBS	R10,OPE4		;ERROR
	$FAB_STORE	-		;SET FAB FIELDS
		FAB=R1, -
		FNA=STRING,FNS=LEN
	$OPEN	FAB=R1			;OPEN OLD FILE MACRO
	BLBS	R0,OPE3
	TSTL	R9
	BNEQ	OPE2			;OPEN OLD FILE FAILED
	MOVL	#3,R10
	JMP	OPE4
OPE2:	JSB	UNIT			;GET FAB AND RAB AGAIN
	BLBS	R10,OPE4		;ERROR
	CMPL	#2,R9			;CHECK IF SCRATCH FILE
	BNEQ	OPE1
	$FAB_STORE	FAB=R1, -
			FOP=<CBT,TMD>	;TEMPORARY FILE
OPE1:	$FAB_STORE	-		;SET FAB
		FAB=R1, -
		FNA=STRING,FNS=LEN
	$CREATE	FAB=R1			;OPEN NEW FILE MACRO
	BLBS	R0,OPE3			;SUCCESSFUL CREATION
	MOVL	#4,R10
	JMP	OPE4
OPE3:	TSTL	R10
	BGTR	OPE4			;ERROR, DO NOT CONNECT RAB
	$CONNECT	RAB=R2		;CONNECT RAB
	BLBS	R0,OPE4
	MOVL	#5,R10
OPE4:	MOVL	R10,@16(AP)		;RETURN IERR
	RET
;
;***********************************************************************
;
;
;   SUBROUTINE BIOMFW(IU,A,NBYTES,NBLOCK,IERR)
;
;   WRITE ON FILE IU
;
;   IU     - LOGICAL UNIT NO. (1-11)
;   A      - FIRST WORD ADDRESS OF STRING TO BE WRITTEN ON DISC
;   NBYTES - NO. OF BYTES TO BE WRITTEN
;   NBLOCK - VIRTUAL BLOCK # OF FIRST BLOCK ON THE FILE
;            WHERE RECORD A STARTS
;   IERR   - ERROR CODE =0 SUCCESSFUL COMPLETION
;                       =1 WRONG UNIT NO.
;                       =2 WRITE/READ ERROR (WRONG BLOCK,DEVICE FULL,..)
;
;
;***********************************************************************
;
	.ENTRY	BIOMFW,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	JSB	UNIT			;GET (FAB),(RAB)
	BLBS	R10,WR3			;ERROR TEST
	MOVL	8(AP),R7		;(A) IN R7
	MOVL	@12(AP),R8		;# BYTES IN R8
	MOVL	@16(AP),R5		;BLOCK # IN R5
WR0:	MOVL	R8,R4			;CURRENT # BYTES IN R4
	CMPL	R4,MAXLEN		;CHECK IF GT MAXLEN
	BLEQ	WR1
	MOVL	MAXLEN,R4		;IF TRUE, R4=MAXLEN
WR1:	MOVL	R5,RAB$L_BKT(R2)	;SET BLOCK # IN RAB
	CVTLW	R4,RAB$W_RSZ(R2)	;SET # OF BYTES IN RAB
	MOVL	R7,RAB$L_RBF(R2)	;SET (A) IN RAB
	$WRITE	RAB=R2			;WRITE MACRO
	BLBS	R0,WR2
	MOVL	#2,R10
	JMP	WR3
WR2:	SUBL2	MAXLEN,R8		;CHECK HOW MUCH IS LEFT
	TSTL	R8
	BLEQ	WR3			;ALL DONE
	ADDL2	MAXBLO,R5			;INCREASE BLOCK #
	ADDL2	MAXLEN,R7		;INCREASE (A)
	JMP	WR0
WR3:	MOVL	R10,@20(AP)
	RET
;
;***********************************************************************
;
;
;   SUBROUTINE BIOMFR(IU,A,NBYTES,NBLOCKS,IERR)
;
;   READ FROM FILE IU
;
;   READ IN BLOCK MODE FROM DISC FILE.
;   SAME ARGUMENTS AS BIOMFW.
;
;
;***********************************************************************
;
	.ENTRY	BIOMFR,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	JSB	UNIT			;GET (FAB),(RAB)
	BLBS	R10,RR3			;ERROR TEST
	MOVL	8(AP),R7		;(A) IN R7
	MOVL	@12(AP),R8		;# BYTES IN R8
	MOVL	@16(AP),R5		;BLOCK # IN R5
RR0:	MOVL	R8,R4			;CURRENT # BYTES IN R4
	CMPL	R4,MAXLEN		;CHECK IF GT MAXLEN
	BLEQ	RR1
	MOVL	MAXLEN,R4		;IF TRUE, R4=MAXLEN
RR1:	MOVL	R5,RAB$L_BKT(R2)	;SET BLOCK # IN RAB
	CVTLW	R4,RAB$W_USZ(R2)	;SET # OF BYTES IN RAB
	MOVL	R7,RAB$L_UBF(R2)	;SET (A) IN RAB
	$READ	RAB=R2			;READ MACRO
	BLBS	R0,RR2
	MOVL	#2,R10
	JMP	RR3
RR2:	SUBL2	MAXLEN,R8		;CHECK HOW MUCH IS LEFT
	TSTL	R8
	BLEQ	RR3			;ALL DONE
	ADDL2	MAXBLO,R5		;INCREASE BLOCK #
	ADDL2	MAXLEN,R7		;INCREASE (A)
	JMP	RR0
RR3:	MOVL	R10,@20(AP)
	RET
;
;***********************************************************************
;
;
;   SUBROUTINE BIOMFC(IU,IERR)
;
;   CLOSE FILE IU
;
;   IU    - LOGICAL UNIT NO.
;   IERR  - ERROR CODE,  =0 SUCCESSFUL CLOSE
;                        =1 WRONG UNIT NO.
;                        =2 CLOSE ERROR
;
;
;***********************************************************************
;
	.ENTRY	BIOMFC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	JSB	UNIT
	$CLOSE	FAB=R1			;CLOSE MACRO
	BLBS	R0,CL1			;ERROR EXIT
	MOVL	#2,R10
CL1:	MOVL	R10,@8(AP)
	RET
;
;   SUBROUTINE UNIT, GET (FAB) AND (RAB)
;
UNIT:	CLRL	R10			;CLEAR ERROR REG.
	MOVL	@4(AP),R4
	CMPL	R4,#11			;CHECK IU LIMITS
	BGTR	UNIT0
	TSTL	R4
	BGTR	UNIT1
UNIT0:	INCL	R10
	RSB
UNIT1:	ASHL	#2,R4,IU		;*4
	MOVL	#FABAD,R2
	MOVL	#RABAD,R3
	ADDL2	IU,R2
	ADDL2	IU,R3
	MOVL	(R2),R1			;(FAB) IN R1
	MOVL	(R3),R2			;(RAB) IN R2
	RSB
	.END
--------------------------------



bio.c  (block I/O routine written in C (used in UNIX versions)
--------------------------------------

/*  BLK***:  low-level block i/o routines written in C-language with
 *           appropriate hooks into the Unix kernal through the
 *           standard interface definitions (System V & Berkeley 4.*)
 *
 *  collected together below are all of the required 'header' files
 *
 */

#include   <stdio.h>
#include   <sys/types.h>
#include   <sys/file.h>
#include   <sys/stat.h>
#include   <errno.h>

/*
 *    define all global variables here
 *    for use in all of the functions
 */

int     PRUBLK =  512;         /* preset block/buffer size    */
int     NCPW   =    4;         /* no. characters per word     */

#define MAXFD    64            /* max no. of file descriptors */
char   *fnpt[MAXFD];           /* array of file name pointers */
char    ftyp[MAXFD];           /* file type option (char)     */

/*
 *    make lint happy
 */

extern char  *malloc();
extern char  *strcpy();
extern int    printf();
extern int    open();
extern int    read();
extern int    write();
extern int    close();
extern int    fstat();
extern long   lseek();

/* end */

/*  BLKOPN:  open a file for randon i/o, given it's path name
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkopn (path, opt, fd, size, ierr)
 *      ------------------------------------------
 *
 *  input arguements:
 *
 *    path  =  complete 'path' name of file
 *    opt   =  2 character open option flags, where
 *             opt[0] = 'r' for 'read_only'
 *                      'w' for 'write_append'
 *                      ' ' for both 'read_write'
 *             opt[1] = 'o' for  'existing'  file open
 *                      'n' for 'create_new' file open
 *                      's' for 'scratch'    file open
 *                      ' ' for 'create_new' even if file
 *                          already exists (truncate old)
 *
 *  output arguements:
 *
 *    fd    =  file descriptor for open file
 *    size  =  size of file (in words)
 *    ierr  =  error return number (zero if no error)
 *
 */

/**********************
 *  entry  -  BLKOPN  *
 **********************/

blkopn_(path, opt, fd, size, ierr, lpath, lopt)

char       *path, *opt;
long int   *fd,   *size, *ierr, lpath, lopt;

{

     char         oc,  fnam[256];
     static char  *op, *pp;
     static int   lop, lpp;
     unsigned     lfnam;

     int          i, flags, mode, acc;
     struct stat  stbuf;

     *ierr =  0;                         /* clear the user error code */
     errno =  0;                         /* clear error code no.      */

     /* create C-pointers and lengths for FORTRAN character strings */

     pp   =  path;
     lpp  =  lpath;

     op   =  opt;
     lop  =  lopt;

     /* transfer FORTRAN character string (path) to local array fnam[] */

     i   =  0;
     while ((*pp != '\0') && (*pp != ' ') && (i < lpp))
       {
       fnam[i++] = *(pp++);
       }
     fnam[i] =  '\0';
     lfnam   =  i + 1;

     /* setup open options by checking file status */

     oc    =  'c';                     /* set open/create flag = 'create' */
     acc   =  access(fnam, F_OK);      /* attempt to access the file  */

     if (acc == -1)                    /* file does not exist */
       {                               /* =================== */
       if (*(op+1)=='o')               /* user option says 'old' */
         {
         printf ("\n");
         printf (" BLKOPN: file does not exist !\n");
         printf (" BLKOPN:   fnam = %s\n", fnam);
         printf (" BLKOPN: opt[2] = %s\n", *(op+1));
         printf ("\n");
         blkerr_(errno, ierr);         /* extract error number  */
         return;                       /* return to user */
         }
       }
     else                              /* file exists */
       {                               /* =========== */
       if (*(op+1)=='n')               /* user option says 'new' */
         {
         printf ("\n");
         printf (" BLKOPN: file already exists, user opt = 'new' !\n");
         printf (" BLKOPN:   fnam = %s\n", fnam);
         printf (" BLKOPN: opt[2] = %s\n", *(op+1));
         printf ("\n");
         errno = EEXIST;               /* set 'exists' error message */
         blkerr_(errno, ierr);         /* extract error number  */
         return;                       /* return to user */
         }
       else                            /* user option says 'old/both' */
         oc = 'o';                     /* set open/create flag = 'open' */
       }

     mode  =  0644;                    /* set protection = (rw_,r__,r__) */

     flags =  0;                       /* set open 'flags' using (opt)   */

     if (*(op) == 'r')     flags = flags | O_RDONLY;
     if (*(op) == 'w')     flags = flags | O_WRONLY | O_APPEND;
     if (*(op) == ' ')     flags = flags | O_RDWR;

     if (*(op+1) == 'o')   flags = flags | O_EXCL;
     if (*(op+1) == 'n')   flags = flags | O_CREAT  | O_EXCL;
     if (*(op+1) == 's')   flags = flags | O_CREAT;
     if (*(op+1) == ' ')   flags = flags | O_CREAT;

  /* flags = flags | O_RAW;               invoke UNBUFFERED i/o      */

     *size =  0;                       /* set defaults for file size */

     *fd = open(fnam, flags, mode);    /* open/create file 'path' */

     if (*fd == -1)                    /* error on open/create request  */
       {
       printf ("\n");
       printf (" BLKOPN: cannot open file !\n");
       printf (" BLKOPN:  fnam = %s\n", fnam);
       printf (" BLKOPN: flags = %o\n", flags);
       printf (" BLKOPN:  mode = %o\n", mode);
       printf ("\n");
       blkerr_(errno, ierr);           /* extract error number          */
       }
     else                              /* valid file open, check status */
       {
       if (fstat((int)*fd, &stbuf) == -1)  /* error in status request ? */
         {
         printf ("\n BLKOPN:  *fd = %d  has a bad status !\n", *fd);
         blkerr_(errno, ierr);         /* extract error number          */
         }
       else                            /* valid status info             */
         {
         *size = stbuf.st_size/NCPW;   /* set 'size' = file size (word) */
         blkerr_(NULL, ierr);          /* clear error number            */
         }
       }

     /* save file name (fnam) and type (opt[1]) for use by BLKCLO */

     if ((*fd < 0) | (*fd >= MAXFD))   /* check for (fd) out of range     */
       {
       printf ("\n");
       printf (" BLKOPN: (*fd) out of range !\n");
       printf (" BLKOPN:  fnam = %s\n", fnam);
       printf (" BLKOPN:   *fd = %d\n", *fd);
       printf (" BLKOPN: MAXFD = %d\n", MAXFD);
       printf ("\n");
       errno  =  1;                    /* set error no. = 1 (local error) */
       blkerr_(errno, ierr);
       }

     fnpt[(int)*fd]  =  malloc(lfnam); /* allocate storage for file name */
     strcpy (fnpt[(int)*fd], fnam);    /* copy (fnam) to this storage    */

     ftyp[(int)*fd]  =  *(op+1);       /* save file type (opt[1])        */

     return;
}

/* end */ 

/*  BLKPOS:  position file 'fd' to starting block no. 'blk'
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkpos (fd, blk, pos, ierr)
 *      -----------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *    blk   =  starting 'block' number in file
 *
 *  output arguements:
 *
 *    pos   =  file position (in bytes)
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKPOS  *
 ********************/

blkpos_(fd, blk, pos, ierr)

long int   *fd, *blk, *pos, *ierr;

{

     long int     offset;

     *ierr =  0;                       /* clear the user error code */
     errno =  0;                       /* clear error code no.      */

     offset =  PRUBLK * (*blk - 1);    /* (byte_wise) offset for 'blk' */

     *pos = lseek((int)*fd, 0L, L_INCR);  /* check current file position */

     if (*pos != offset)               /* if not at offset, put it there */
       {
       *pos  =  lseek((int)*fd, offset, L_SET);

       if (*pos == -1)                 /* error in lseek call ? */
         {
         printf ("\n");
         printf (" BLKPOS: can not position file by lseek(---)\n");
         printf (" BLKPOS:     fd = %d\n", *fd);
         printf (" BLKPOS:    blk = %d\n", *blk);
         printf (" BLKPOS: offset = %d\n", offset);
         printf ("\n");
         blkerr_(errno, ierr);         /* extract error number   */
         }
       }
     else                              /* valid status info      */
       {
       blkerr_(NULL, ierr);            /* clear error number     */
       }
     return;
}

/* end */ 

/*  BLKRDR:  read 'n' words from file 'fd', starting at block no. 'blk'
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkrdr (fd, buf, nwds, blk, ierr)
 *      -----------------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *    buf   =  pointer to buffer string (char)
 *    nwds  =  number of words (long int) to read in
 *    blk   =  starting 'block' number in file
 *
 *  output arguements:
 *
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKRDR  *
 ********************/

blkrdr_(fd, buf, nwds, blk, ierr)

char       *buf;
long int   *fd, *nwds, *blk, *ierr;

{

     int         nbuf, ibuf;
     long int    pos,  offset;

     *ierr =  0;                       /* clear the user error code */
     errno =  0;                       /* clear error code no.      */

     nbuf   =  *nwds * NCPW;           /* no_bytes = NCPW * no_words  */
     offset =  PRUBLK * (*blk - 1);    /* (byte_wise) offset of 'blk' */

     if (offset >= 0)                  /* position file before read request */
       {
       pos   =  lseek((int)*fd, offset, L_SET);

       if (pos == -1)                  /* error condition in lseek call  */
         {
         printf ("\n");
         printf (" BLKRDR: can not position file by lseek(---)\n");
         printf (" BLKRDR:     fd = %d\n", *fd);
         printf (" BLKRDR:    blk = %d\n", *blk);
         printf (" BLKRDR: offset = %d\n", offset);
         printf ("\n");
         blkerr_(errno, ierr);         /* extract error number           */
         return;
         }
       }

     ibuf  =  read((int)*fd, buf, nbuf);   /* read 'nbuf' bytes to 'buf' */

     if ((ibuf == -1) || (ibuf != nbuf))    /* error condition on read */
       {
       printf ("\n");
       printf (" BLKRDR:    *fd = %d  has a bad read!\n", *fd);
       printf (" BLKRDR:    blk = %d\n", *blk);
       printf (" BLKRDR: offset = %d\n", offset);
       printf (" BLKRDR:   nwds = %d  (requested)\n", *nwds);
       printf (" BLKRDR:   nbuf = %d  (requested)\n", nbuf);
       printf (" BLKRDR:   ibuf = %d  (actual read)\n", ibuf);
       printf ("\n");
       if ((ibuf != nbuf) && (errno == 0))
	 {
	   errno  =  -1;
         }
       blkerr_(errno, ierr);           /* extract error number */
       }
     else
       {
       blkerr_(NULL, ierr);            /* clear error number */
       }
     return;
}

/* end */ 

/*  BLKWTR:  write 'n' words to file 'fd', starting at block no. 'blk'
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkwtr (fd, buf, nwds, blk, ierr)
 *      -----------------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *    buf   =  pointer to buffer string (long int)
 *    nwds  =  number of words (long int) to write out
 *    blk   =  starting 'block' number in file
 *
 *  output arguements:
 *
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKWTR  *
 ********************/

blkwtr_(fd, buf, nwds, blk, ierr)

char       *buf;
long int   *fd, *nwds, *blk, *ierr;

{

     int         nbuf, ibuf;
     long int    pos,  offset;

     *ierr =  0;                       /* clear the user error code */
     errno =  0;                       /* clear error code no.      */

     nbuf   =  *nwds * NCPW;           /* no_bytes = NCPW * no_words  */
     offset =  PRUBLK * (*blk - 1);    /* (byte_wise) offset of 'blk' */

     if (offset >= 0)                  /* position file before write request */
       {
       pos = lseek((int)*fd, offset, L_SET);

       if (pos == -1)                  /* error condition in lseek call ? */
         {
         printf ("\n");
         printf (" BLKWTR: can not position file by lseek(---)\n");
         printf (" BLKWTR:     fd = %d\n", *fd);
         printf (" BLKWTR:    blk = %d\n", *blk);
         printf (" BLKWTR: offset = %d\n", offset);
         printf ("\n");
         blkerr_(errno, ierr);         /* extract error number            */
         return;
         }
       }

     ibuf  =  write((int)*fd, buf, nbuf); /* write 'nbuf' bytes to 'buf'  */

     if ((ibuf == -1) || (ibuf != nbuf))    /* error condition on write */
       {
       printf ("\n");
       printf (" BLKWTR:    *fd = %d  has a bad write!\n", *fd);
       printf (" BLKWTR:    blk = %d\n", *blk);
       printf (" BLKWTR: offset = %d\n", offset);
       printf (" BLKWTR:   nwds = %d  (requested)\n", *nwds);
       printf (" BLKWTR:   nbuf = %d  (requested)\n", nbuf);
       printf (" BLKWTR:   ibuf = %d  (actual write", ibuf);
       printf ("\n");
       if ((ibuf != nbuf) && (errno == 0))
	 {
	   errno  =  -1;
         }
       blkerr_(errno, ierr);           /* extract error number */
       }
     else
       {
       blkerr_(NULL, ierr);            /* clear error number */
       }

     return;
}

/* end */ 

/*  BLKCLO:  close (/delete) a file from randon i/o, given it's descriptor
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkclo (fd, opt, size, ierr)
 *      ------------------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file (for closing)
 *    opt   =  1 character close option flag, where
 *             opt = ' ' for normal close
 *                   'd' for close/delete option
 *
 *  output arguements:
 *
 *    size  =  size of file (in words)
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKCLO  *
 ********************/

blkclo_(fd, opt, size, ierr, lopt)

char       *opt;
long int   *fd,  *size, *ierr;
long int   lopt;

{

     static char  *op;
     static int   lop;

     struct stat  stbuf;

     *ierr =  0;                        /* clear the user error code */
     errno =  0;                        /* clear the error code no.  */

     /* create C-pointers and lengths for FORTRAN character strings */

     op   =  opt;
     lop  =  lopt;

     /* first, extract the file's stats for return */

     if (fstat((int)*fd, &stbuf) == -1)  /* error in status request ? */
       {
       *size = 0;                      /* clear file statistics  */
       printf ("\n BLKCLO:  *fd = %d  has a bad status !\n", *fd);
       blkerr_(errno, ierr);           /* extract error number   */
       }
     else                              /* valid status info      */
       {
       *size = stbuf.st_size/NCPW;     /* set 'size' = file size (word) */
       blkerr_(NULL, ierr);            /* clear error number            */
       }

     /* second, close the file pointed to by 'fd' */

     if (close((int)*fd) == -1)        /* error on close request ? */
       {
       printf ("\n");
       printf (" BLKCLO: can not close file !\n");
       printf (" BLKCLO:   *fd = %d\n", *fd);
       printf (" BLKCLO:   opt = %s\n",  op);
       printf ("\n");
       blkerr_(errno, ierr);           /* extract error number   */
       return;
       }

     /* last, check option and delete file if request is on */

     if ((*op == 'd') || (ftyp[*fd] == 's'))    /* delete option on ? */
       {                                        /* or  scratch file ? */

       /* unlink/delete the file (name) pointed to by fnpt[*fd] */

       if (unlink(fnpt[(int)*fd]) == -1)   /* error on delete request ? */
         {
         printf ("\n");
         printf (" BLKCLO: can not unlink file !\n");
         printf (" BLKCLO:   *fd = %d\n", *fd);
         printf (" BLKCLO:  fnam = %s\n", fnpt[*fd]);
         printf (" BLKCLO:   opt = %s\n", op);
         printf ("\n");
         blkerr_(errno, ierr);             /* extract error number    */
         }
       }
     return;
}

/* end */ 

/*  BLKSTA:  extract the current status of a file
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blksta (fd, ierr)
 *      -------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *
 *  output arguements:
 *
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKSTA  *
 ********************/

blksta_(fd, ierr)

long int   *fd, *ierr;

{

     struct stat  stbuf;
     ushort       mode, uid,  gid;
     short        nlnk;
     off_t        size;
     int          bksz, blks;
     time_t       atim, mtim, ctim;
     ino_t        ino;

     printf ("\n");
     printf (" BLKSTA:    fd = %8x\n", *fd);

     if (fstat((int)*fd, &stbuf) == -1)  /* error in status request ?    */
       {
       printf ("\n BLKSTA:  *fd = %d  has a bad status !\n", *fd);
       blkerr_(errno, ierr);           /* extract error number           */
       }
     else                              /* valid status info              */
       {
       ino  = stbuf.st_ino;            /* set 'ino'  = inode number      */
       nlnk = stbuf.st_nlink;          /* set 'nlnk' = no. hard links    */
       mode = stbuf.st_mode;           /* set 'mode' = file protection   */
       uid  = stbuf.st_uid;            /* set 'uid'  = user-id of owner  */
       gid  = stbuf.st_gid;            /* set 'gid'  = group-id of owner */
       size = stbuf.st_size/NCPW;      /* set 'size' = file size (words) */
       bksz = PRUBLK/NCPW;             /* set 'bksz' = file block size   */
       blks = (size-1)/bksz + 1;       /* set 'blks' = no. of blocks     */
       atim = stbuf.st_atime;          /* set 'atim' = last access time  */
       mtim = stbuf.st_mtime;          /* set 'mtim' = last modify time  */
       ctim = stbuf.st_ctime;          /* set 'ctim' = last change time  */

       blkerr_(NULL, ierr);            /* clear error number             */

       printf (" BLKSTA: ino  (hex) = %8x\n", ino);
       printf (" BLKSTA: nlnk (dec) = %8d\n", nlnk);
       printf (" BLKSTA: mode (oct) = %8o\n", mode);
       printf (" BLKSTA: uid  (dec) = %8d\n", uid);
       printf (" BLKSTA: gid  (dec) = %8d\n", gid);
       printf (" BLKSTA: size (dec) = %8d\n", size);
       printf (" BLKSTA: bksz (dec) = %8d\n", bksz);
       printf (" BLKSTA: blks (dec) = %8d\n", blks);
       printf (" BLKSTA: atim (hex) = %16x\n", atim);
       printf (" BLKSTA: mtim (hex) = %16x\n", mtim);
       printf (" BLKSTA: ctim (hex) = %16x\n", ctim);
       printf ("\n");

       }
     return;
}

/* end */ 

/*  blkerr:  return a system error number, given 'erno'
 *
 *      blkerr_(erno, ierr)
 *     ---------------------
 *
 *  input arguements:
 *
 *    erno    =  system error number
 *               if erno =         0,  NULL error, ierr = 0
 *                  erno <         0,  undefined,  ierr = -1
 *                  erno >  sys_nerr,  undefined,  ierr = -1
 *
 *  output arguements:
 *
 *    ierr    =  error number (zero if 'erno' == NULL)
 *
 */

/********************
 *  entry - BLKERR  *
 ********************/

blkerr_(erno, ierr)

int        erno;
long int  *ierr;

{

  extern int   sys_nerr;        /* largest error no. for which system  */
                                /* system tables has a defined message */
  extern char *sys_errlist[];   /* table of system error messages      */

    if (erno == NULL)           /* NULL error message returned */
      {
      *ierr =  0;
      return;
      }

    if (erno>0 && erno<sys_nerr)
      {
      *ierr =  erno;
      printf (" BLKERR: ierr = %4d  (%s)", errno, sys_errlist[erno]);
      }
    else
      {
      *ierr =  -1;
      printf (" BLKERR: ierr = %4d  (unkown error value ?)", errno);
      }

  return;
}

/* end */ 

/*  BLKLOC:  extract the current position within a file
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkloc (fd, size, pos, ierr)
 *      ------------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *
 *  output arguements:
 *
 *    size  =  size of file (in words)
 *    pos   =  position within file returned by lseek(2)
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKLOC  *
 ********************/

blkloc_(fd, size, pos, ierr)

long int   *fd, *size, *pos, *ierr;

{

     struct stat  stbuf;

     *ierr =  0;                         /* clear the user error code */
     errno =  0;                         /* clear error code no.      */

     *pos  =  lseek ((int)*fd, 0L, L_INCR);  /* extract position of file */

     if (fstat((int)*fd, &stbuf) == -1)     /* error in status request ? */
       {
       *size = 0;                      /* clear file statistics  */
       printf ("\n BLKLOC:  *fd = %d  has a bad status !\n", *fd);
       blkerr_(errno, ierr);           /* extract error number   */
       }
     else                              /* valid status info      */
       {
       *size = stbuf.st_size/NCPW;     /* set 'size' = file size (word) */
       blkerr_(NULL, ierr);            /* clear error number            */
       }
     return;
}

/* end */ 

/*  BLKRTN:  delete a file from randon i/o, given it's descriptor
 *
 *  this routine is called in fortran (f77) via:
 *
 *       call  blkrtn (fd, ierr)
 *      -------------------------------
 *
 *  input arguements:
 *
 *    fd    =  file descriptor for file
 *
 *  output arguements:
 *
 *    ierr  =  error return number (zero if no error)
 *
 */

/********************
 *  entry - BLKRTN  *
 ********************/

blkrtn_(fd, ierr)

long int   *fd,  *ierr;

{

     *ierr =  0;                        /* clear the user error code */
     errno =  0;                        /* clear the error code no.  */


     /* unlink/delete the file pointed to by fnpt[*fd] */

     if (unlink(fnpt[(int)*fd]) == -1)  /* error on delete request ? */
       {
       printf ("\n");
       printf (" BLKRTN: can not unlink file !\n");
       printf (" BLKRTN:   *fd = %d\n", *fd);
       printf (" BLKRTN:  fnpt = %s\n", fnpt[*fd]);
       printf ("\n");
       blkerr_(errno, ierr);            /* extract error number    */
       }

     return;
}
----------------------------------------



Perhaps this information will help you generate efficiently working
versions of Bushnell's codes on DEC ALPHA running under VMS.


Sincerely,
David Bushnell
======================================================================


PART X
