C=DECK      READITLIB
C
C  THIS IS THE READIT LIBRARY (SOURCE FILE)
C
C
C
C=DECK      READIT
      PROGRAM B5READ
C
C  200-SEGMENT VERSION OF BOSOR5
C
C
#if hp700
$hp9000_800 intrinsics
#endif
      COMMON/IDENTS/IC,IT,IR,IDS,IDB,IDP,IDSH,IM,ITS,ITSH,IZST,IDARC,IZX
      COMMON/IDENT2/ IANGLE,ISIGR,IEPSR,IEPCPR
      COMMON/RINDEX/JBEGIN,KBEGIN,LBEGIN,KRSEG
      COMMON/IBUNCH/INOW,INOWH,INOWZ,MPROPX,NANR,NSME,NQ1,NQ2,NQ3,ICHNGE
      COMMON/BUCKN/ N0B,NMINB,NMAXB,INCRB
      COMMON/TIMLFT/MARGIN,NBEGIN
      COMMON/INSTAB/INDIC
      COMMON/IFLOWS/IFLOW,ICREEP,IJNCT,IJNTB,ITSTOR,ITHSTR,IZSTOR,IBSTOR
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/NCONDS/NCOND
      COMMON/TOTPTS/M3
      COMMON/SHEL/IWAL(201)
      COMMON/NBGSTP/NBEG(201),NSTOPP(201)	,INTVAL(201)
      COMMON/THERWD/NWORD(201),NPLAST(201),NCREEP(201),NMAT(201),
     1              NALRED(201)
      COMMON/SEGS/NSEG,M2,I5(201),I2,I2G
      COMMON/BLK/IBLK,NGBK(20),NKF(20)
      COMMON/BKSIZE/IMAXP,IMAXB,KMAXP(20),KMAXB(20)
      COMMON/BLKP/IBLKP,NGBKP(20),NKFP(20)
      COMMON/LOCATN/ILOCP,ILOCB,IROWCP(201),IROWCB(201),IIWP,IIWB
      COMMON/SEGBND/ISEGA,ISEGB,I2AB,NCONDB
      COMMON/RBODY/ISTOP0(6),ISTOP1(6)
      COMMON/ZREGNS/NREGNS,IREGN(10,2)
      COMMON/IGOVN/ITTURE(201),IDEPTH(201),IREFZ(201),ILONG
      COMMON/GLOBAL/IDZ,IZRING(99),ISAVE(20),INOTE
      COMMON/RPLST4/JBEG(99),KBEG(10),NPOINT(10) ,NSUM1(199),NSUM2(199)
      COMMON/RPLST5/NTYP(99),NPARTS(99)
      COMMON/HED/TITLE(12)
      COMMON/RING4/D1B(201),D2B(201)
      COMMON/RING3/D1(201),D2(201)
      COMMON/PLTSIG/IPLOT,JPLOT,KPLOT(20),LPLOT(20),MPLOT,RN(20),ZN(20)
      COMMON/MATP2/ETAN(20,9),MAXTRL,ITRIAL,EMAX(9),ATWEEN(95),SBRDF(95)
      COMMON/MATPRO/EPEFF(20,9),SGEFF(20,9),NITEG(9),EE(9),FNUE(9),AP(9)
      COMMON/CDATA/TFLOOR,CREEPN(9),CREEPM(9),CREEPA(9),CREEPB(9)
      COMMON/EIGNO/NVEC,EGV(50),AXB
      COMMON/PRERT/PREROT
      COMMON/TLOADS/FTLOAD(100,2),NTIME(11),ITIME
      COMMON/ERROR/ERR
      COMMON/RPLST1 /R1(99),R2(99),PHI(99),T(99),FL(99),E(10),ALPHA(10)
      COMMON/RPLST2/TEMP(100),EPS(100),SIGMA(100)
      COMMON/CMAXS/CMAX
      COMMON/CLST/CLAST
      COMMON/FORCES/V(99),HF(99),FM(99)
      COMMON/STEPS/DTEMP(201),STEP(201),STEP1(99),STEP2(99),STEP3(99)
      COMMON/RCDATA/RCREEN(9),RCREEM(9),RCREEA(9),RCREEB(9)
      COMMON/AUXSTO/IDD,ISER,ILAST,ICUR,ISTAT
      COMMON/IDENT/IPRW(20)
      COMMON/BCK/IDRW(20,5)
      COMMON/IDEIG/IVEC(50),NTRY
      COMMON/SMODE/IPMODE(99),ICMODE(99),ISMODE(99),IQMODE(99),IHMOD(99)
      COMMON/OUTP/NPRT
      COMMON/ORTHP/AL1(20),AL2(20),EXX(20),EYY(20),FNUXY(20),GS(20)
      COMMON/PRMFIL/IFILE,IFILE2,IOUT,IPRM(5)
      COMMON/PRMOUT/IFILE3,IFILE4
      COMMON/ISETP/ISETUP
      COMMON/IDHIGH/IDMAX
      COMMON/INDAT/INFILE
      CHARACTER*4 ANSOUT
      CHARACTER*4 CHARAC
      LOGICAL ANSL1
      common/case/casename
      character*28 casename
      character*32 fname
      logical exists
      integer stofile
C BEG FEB 2009
#if hp700
C     call getarg(2, casename)
      call getarg(1, casename)
#else
      call getarg(1,casename)
#endif
C END FEB 2009
C
      ISETUP = 0
      IDMAX = 0
      IOUT = 3
      IFILE = 2
      IFILE2 = 4
      IFILE3 = 7
      INFILE = 5
      IFILE4 = 8
C
C
C FOLLOWING USED FOR VAX/VMS..
c     OPEN(UNIT=IFILE,FILE='BOSOR5:PROMPT.DAT',STATUS='OLD',READONLY)
c     OPEN(UNIT=IFILE2,FILE='BOSOR5:PROMPT2.DAT',STATUS='OLD',READONLY)
c     OPEN(UNIT=IFILE3,FILE='BOSOR5:PROMPT3.DAT',STATUS='OLD',READONLY)
C END VAX/VMS OPEN STATEMENTS
C
C FOLLOWING USED FOR UNIX...
      OPEN(UNIT=IFILE,FILE='PROMPT.DAT',STATUS='OLD')
      OPEN(UNIT=IFILE2,FILE='PROMPT2.DAT',STATUS='OLD')
      OPEN(UNIT=IFILE3,FILE='PROMPT3.DAT',STATUS='OLD')
#if rs6k
      rewind(IFILE)
      rewind(IFILE2)
      rewind(IFILE3)
#endif
C END UNIX OPEN STATEMENTS
C
      fname = casename(1:index(casename, ' ')-1)//'.DOC'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=IOUT, FILE=fname, STATUS='OLD')
#if rs6k
        rewind(iout)
#endif
      else
	OPEN(UNIT=IOUT, FILE=fname, STATUS='NEW')
      endif
c
      fname = casename(1:index(casename, ' ')-1)//'.OUT'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
        OPEN(UNIT=IFILE4, FILE=fname, STATUS='OLD')
#if rs6k
        rewind(ifile4)
#endif
      else
        OPEN(UNIT=IFILE4, FILE=fname, STATUS='NEW')
      endif
C
C
      CALL GASP(DUM1,DUM2,-1,DUM3)
      NPRT = 2
C
C     SR100T(1)	INITIALIZE THE CLOCK.
C     SR100T(2)	CAUSES ELAPSED TIME TO BE PRINTED OUT.
C
      CALL SR100T(1)
   10 FORMAT(12A4)
C  10 FORMAT(7A10)     (CDC VERSION)
C
C     TITLE . .	TITLE  OF CASE,	FIRST 41 CHARACTERS OF WHICH APPEAR ON
C		PLOTS.
C     NSEG = NO. OF SHELL SEGMENTS
C
      CALL DATUM(IFILE,1,0,0,INT,REALL,CHARAC,IOUT,0,1)
      WRITE(6,53)
   53 FORMAT(//' Please provide a title (42 characters or less)...'/)
      READ(5,10) (TITLE(I),I=1,12)
      WRITE(IOUT,11) (TITLE(I),I=1,12)
      WRITE(IFILE4,11) (TITLE(I),I=1,12)
   11 FORMAT(1X,12A4)
C
C     READ(5,10) (TITLE(I),I=1,7)	(CDC VERSION)
   20 FORMAT(12I6)
      CALL DATUM(IFILE,10,1,1,NSEG,REALL,CHARAC,IOUT,0,1)
C     NSEG = NUMBER OF SHELL SEGMENTS.
C     WRITE(6,21) (TITLE(I)= I=1,7)   (CDC VERSION)
   30 FORMAT(1X,12A4//)
C  21 FORMAT(1X, 7A10)	  (CDC VERSION)
      WRITE (IFILE4,40)NSEG
   40 FORMAT(29H   NUMBER OF SHELL SEGMENTS =   I3//)
      IPRE = 27
      ICREEP = 0
C
C
      CALL SEGMNT
C
C     OVERLAY SEGMNT CAUSES DATA TO BE READ IN FOR EVERY SHELL SEGMENT.
C     CALL OVERLAY(5HBREAD,1,0)	  (CDC VERSION)
C
      CALL HOOKUP
C
C     HOOKUP CAUSES JUNCTURE AND BOUNDARY CONDITIONS TO	BE READ	IN AND
C     CAUSES THE TIME FUNCTIONS	OF THE LOADS TO	BE READ	IN AND THE
C     SKYLINES OF THE EQUATION SYSTEMS TO BE GENERATED.
C     CALL OVERLAY(5HBREAD,2,0)	 (CDC VERSION)
C
      CALL RESTOR
C
C
C     RESTOR CAUSES CERTAIN INFORMATION	TO BE STORED ON	MASS STORAGE
C     IN A CERTAIN ORDER.
C
C     CALL OVERLAY(5HBREAD,3,0)	     (CDC VERSION)
C
      stofile = 9
      fname = casename(1:index(casename, ' ')-1)//'.BLK'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='OLD')
#if rs6k
        rewind(stofile)
#endif
      else
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='NEW')
      endif
      CALL STORCM
      close(stofile)
C
C     STORCM CAUSES CERTAIN COMMON BLOCK DATA TO BE STORED ON PERMANENT
C     FILE SO THAT CASE	CAN BE PROCESSED BY BOSORMAIN OR BMAIN.
C
C     CALL OVERLAY(5HBREAD,4,0)	      (CDC VERSION)
C
      WRITE (IFILE4,50)
   50 FORMAT(//69H DATA READ IN AND PROCESSED FOR THIS CASE. LEAVING SUB
     1ROUTINE READIT     )
      CALL SR100T(2)
      CALL GASP(DUM1,DUM2,-2,DUM3)
c Added 11/90 to clear IEEE FPE warnings
      call ieeexx
c End 11/90
      END
C=DECK      RESTOR
      SUBROUTINE RESTOR
C     OVERLAY(3,0)      (CDC VERSION)
C     PROGRAM RESTOR    (CDC VERSION)
C
      COMMON/FORCES/V(297)
      COMMON/FOSAVE/VSAVE(297)
      COMMON/SHEL/IWAL(201)
      COMMON/SEGS/NSEG,M2,I5(201),I2,I2G
      COMMON/TOTPTS/M3
      COMMON/LOCATN/ILOCP,ILOCB,IROWCP(201),IROWCB(201),IIWP,IIWB
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/IFLOWS/IFLOW,ICREEP,IJNCT,IJNTB,ITSTOR,ITHSTR,IZSTOR,IBSTOR
      COMMON/IGOVN/ITTURE(201),IDEPTH(201),IREFZ(201),ILONG
      COMMON/IDENTS/IC,IT,IR,IDS,IDB,IDP,IDSH,IM,ITS,ITSH,IZST,IDARC,IZX
      COMMON/IDENT2/ IANGLE,ISIGR,IEPSR,IEPCPR
      COMMON/RINDEX/JBEGIN,KBEGIN,LBEGIN,KRSEG
      COMMON/STEPS/DTEMP(201),STEP(201),STEP1(99),STEP2(99),STEP3(99)
      COMMON/SMODE/IPMODE(99),ICMODE(99),ISMODE(99),IQMODE(99),IHMOD(99)
      COMMON/IDENT/IPRW(20)
      COMMON/BCK/IDRW(20,5)
      COMMON/IDEIG/IVEC(50),NTRY
      COMMON/BLK/IBLK,NGBK(20),NKF(20)
      COMMON/BKSIZE/IMAXP,IMAXB,KMAXP(20),KMAXB(20)
      COMMON/BLKP/IBLKP,NGBKP(20),NKFP(20)
      COMMON/IAGINS/IAGIN
      COMMON/PRMOUT/IFILE3,IFILE4
      DIMENSION B(60000),         ILOC(12000),IW(2400),IJUNCT(2614)
      DIMENSION RGLOB(2000),CURV1(2000),CURV2(2000)
C BEG AUG 2005
      COMMON/SMASS/CMASS(2000)
      COMMON/SSARC/SEND,DSTOT,DSS(2000)
      DIMENSION SEGMAS(200)
C END AUG 2005
      DIMENSION ILAST1(20),ILAST2(20)
      DOUBLE PRECISION DB
      DIMENSION DB(30000)
      EQUIVALENCE (B(1),DB(1))
      IAGIN = 0
   10 FORMAT(//48H ENTERING SUBROUTINE RESTOR                         /)
      DO 20 I=1,201
   20 IWAL(I) = 0
      DO 30 I=1,495
   30 IPMODE(I) = 0
      IF (IAGIN.EQ.0) GO TO 50
      CALL GASP(B,550,-3,1)
      DO 40 I=6,500
      I1 = I - 5
   40 IPMODE(I1) = B(I)
   50 CONTINUE
      I10 = 10*I2
      CALL GASP(B(1),I10,3,IC)
      N1 = I10 + 1
      I4 = 4*I2
      CALL GASP(B(N1),I4,3,IT)
      TOME = 0.0
      ITOT = 1
      DO 70 I=1,NSEG
      CALL TLOAD(DTEMP(I),FLOAD,TOME,1)
      IPOS = 4*(ITOT - 1) + N1
      I5I = I5(I)
      I54 = 4*I5I
      DO 60 J=1,I54
      IARG = IPOS + J - 1
      B(IARG) = B(IARG)*FLOAD
   60 CONTINUE
      ITOT = ITOT + I5I
   70 CONTINUE
      N2 = N1 + I4
      IRING = IPRE*NTOT
      CALL GASP(B(N2),IRING,3,IR)
      N3 = N2 + IRING
      N31 = N3 - 1
      CALL GASP(B(1),N31,1,ICMODE(1))
      DO 80 I=1,M2
   80 B(I) = 0.0
      CALL GASP(B(1),M2,1,IPMODE(1))
      CALL GASP(B(1 ),I2,3,IDS)
      N3 = 1
      N4 = N3 + I2
      I55 = 5*I2
      CALL GASP(B(N4),I55,3,IDB)
C     GENERATE RGLOB FOR PLOTTING PURPOSES
      ITOT = 1
C BEG AUG 2005
      TOTMAS = 0.0
C END AUG 2005
      DO 100 ISEG=1,NSEG
      IPOS2 = 5*(ITOT - 1) + N4
      I5I = I5(ISEG)
C BEG AUG 2005
      SEGMAS(ISEG) = 0.
C END AUG 2005
      DO 90 J=1,I5I
      J2 = IPOS2 + J - 1
      J3 = IPOS2 + 2*I5I + J - 1
      J4 = IPOS2 + 3*I5I + J - 1
      K = ITOT + J - 1
      CURV1(K) = B(J3)
      CURV2(K) = B(J4)
C BEG AUG 2005
      RGLOB(K) = B(J2)
      SEGMAS(ISEG) = SEGMAS(ISEG)
     1 + 2.*3.141593*CMASS(K)*DSS(K)*RGLOB(K)
C     WRITE(IFILE4,'(A,3I4,1P,3E12.4)')
C    1' ISEG,J,K,CMASS,DSS,RGLOB=',
C    1 ISEG,J,K,CMASS(K),DSS(K),RGLOB(K)
C END AUG 2005
   90 CONTINUE
      ITOT = ITOT + I5I
C BEG AUG 2005
      TOTMAS = TOTMAS + SEGMAS(ISEG)
      SEGPRT = SEGMAS(ISEG)
      IF (ISEG.EQ.1) WRITE(IFILE4,'(/)')
      WRITE(IFILE4,'(A,I4,A,1P,E12.4)')
     1' Segment No. ISEG=',ISEG,'; Mass of segment(ISEG)=',SEGPRT
      WRITE(IFILE4,'(A,1P,E12.4,A)')
     1' Accumulated mass=',TOTMAS,
     1' NOT INCLUDING DISCRETE RINGS'
C END AUG 2005
  100 CONTINUE
C BEG AUG 2005
      WRITE(IFILE4,'(/,A,/,A,1P,E12.4,/,A)')
     1' ****** TOTAL MASS NOT INCLUDING DISCRETE RINGS ******',
     1' Total mass of all of the shell segment walls=TOTMAS=',
     1 TOTMAS,
     1' ****** TOTAL MASS NOT INCLUDING DISCRETE RINGS ******'
C END AUG 2005
      CALL GASP(RGLOB,I2,1,IWAL(14))
      N5 = N4 + I55
      I3 = 3*I2
      CALL GASP(B(N5),I3,3,IDP)
      N6 = N5 + I3
      II = I2 + 2*NSEG
      CALL GASP(IW,II,3,IIWP)
      DO 110 I=1,II
      I1 = N6 + I - 1
  110 B(I1) = IW(I)
      N7 = N6 + II
      CALL GASP(IJUNCT,2614,3,IJNCT)
      DO 120 I=1,2614
      I1 = N7 + I - 1
  120 B(I1) = IJUNCT(I)
      N10 = N7 + 2614 - 1
      CALL GASP(B(1),N10,1,IWAL( 2))
      CALL GASP(ILOC,M2,3,ILOCP)
      DO 125 I = 1,IBLKP
      IND = NGBKP(I)
  125 ILAST1(I) = ILOC(IND)
      DO 130 I=1,M2
  130 B(I ) = ILOC(I)
      N1D = (M2+1)/2 + 1
      DO 140 I=1,M2
      I1 = N1D + I - 1
  140 DB(I1) = 0.0
C BEG AUG 2003
C     N11 = 3*M2
      N11 = 3*M2 + 2
C END AUG 2003
      CALL GASP(B(1),N11,1,IWAL(15))
      I1 = 2*I2 + 1
      I10 = 10*I2
      DO 150 I=I1,I10
  150 B(I) = 0.0
      DO 160 I=1,I2
      B(I) = CURV1(I)
      IP = I + I2
  160 B(IP) = CURV2(I)
      CALL GASP(B(1),I10,1,IWAL(4))
      I6 = 6*I2
      CALL GASP(B(1),I6,1,IQMODE(1))
C     CALL GASP(B(1),I4,1,IWAL(9))
C     CALL GASP(B(1),I4,1,IWAL(13))
      CALL GASP(B(1),I3,3,IDSH)
      CALL GASP(B(1),I3,1, IHMOD(1))
      IL6 = ILONG*7
      IF (ICREEP.EQ.0) IL6 = ILONG*4
      DO 170 I=1,IL6
  170 B(I) = 0.0
      IL61 = IL6 + 1
      CALL GASP(B(IL61),LBEGIN,3,ISIGR)
      IL2 = IL61 + LBEGIN
      CALL GASP(B(IL2),LBEGIN,3,IEPSR)
      IL3 = IL2 + LBEGIN
      CALL GASP(B(IL3),LBEGIN,3,IEPCPR)
      ILTOT = IL6 + 3*LBEGIN
      CALL GASP(B(1),ILTOT,1,ISMODE(1))
C     CALL GASP(B(1),ILTOT,1,IWAL(11))
      CALL GASP(B(1),ITSTOR,3,ITS)
      N1 = ITSTOR + 1
      CALL GASP(B(N1),ITHSTR,3,ITSH)
      N2 = N1 + ITHSTR
      CALL GASP(B(N2),IZSTOR,3,IZST)
      N3 = N2 + IZSTOR
      CALL GASP(B(N3),I2,3,IDARC)
      N4 = N3 + I2 - 1
      CALL GASP(B(1),N4,1,IWAL(3))
C     NOW GENERATE IWAL(8) GROUP FOR BUCKLING
C
      CALL GASP(B(1),I2,3,IM)
      N4 = I2 + 1
      CALL GASP(B(N4),I55,3,IDB)
      N5 = N4 + I55
      CALL GASP(B(N5),I3,3,IDP)
      N6 = N5 + I3
      CALL GASP(B(N6),I2,3,IDS)
      N7 = N6 + I2
      CALL GASP(IW,II,3,IIWB)
      DO 180 I=1,II
      I1 = N7 + I - 1
  180 B(I1) = IW(I)
      N8 = N7 + II
      CALL GASP(IJUNCT,2614,3,IJNTB)
      DO 190 I=1,2614
      I1 = N8 + I - 1
  190 B(I1) = IJUNCT(I)
      N9 = N8 + 2614
      CALL GASP(ILOC,M3,3,ILOCB)
      DO 195 I = 1,IBLK
      IND = NGBK(I)
  195 ILAST2(I) = ILOC(IND)
      DO 200 I=1,M3
      I1 = N9 + I - 1
  200 B(I1) = ILOC(I)
      ILTOT = N9 + M3 - 1
      CALL GASP(B(1),ILTOT,1,IWAL(8))
  210 CONTINUE
      IMAX2 = 2*IMAXP
      DO 220 I=1,IMAX2
  220 B(I) = 0.0
      DO 230 I=1,IBLKP
      IMAX2 = 2*ILAST1(I)
      IPRW(I) = 0
  230 CALL GASP(B(1),IMAX2,1,IPRW(I))
      IMAX2 = 2*IMAXB
      DO 240 I=1,IMAX2
  240 B(I) = 0.0
      DO 250 I=1,IBLK
      IDRW(I,1) = 0
      IDRW(I,2) = 0
      IDRW(I,5) = 0
      IMAX2 = 2*ILAST2(I)
      CALL GASP(B(1),IMAX2,1,IDRW(I,1))
      CALL GASP(B(1),IMAX2,1,IDRW(I,2))
  250 CALL GASP(B(1),IMAX2,1,IDRW(I,5))
      DO 260 I=1,50
  260 IVEC(I) = 0
      L1 = 5*M2 + 2*IMAXP + 24*I2 + 2*NSEG + IPRE*NTOT + 2614 + 1000
      L2 = 8*M2 + 4*IMAXP
      L3 = 40*I2 + IPRE*NTOT + 2*M2 + 2*NSEG
      KCR = 7
      IF (ICREEP.EQ.0) KCR = 4
      L4 = 28*I2 + KCR*ILONG + 3*LBEGIN + ITSTOR + ITHSTR + IZSTOR
     1  + IPRE*NTOT
C BEG JAN 1996
C     L5 = 2*IMAXB + M3 + 31*I2 + 2614 + 6000 + 2*NSEG + IPRE*NTOT
      L5 = 4*IMAXB + 4*M3 + 31*I2 + 2614 + 4500 + 2*NSEG + IPRE*NTOT
C END JAN 1996
      L6 = 4*IMAXB + 4*M3
      L7 = 4*IMAXB + 8*M3 + 4*M3 + 4
      WRITE (IFILE4,270)
      WRITE (IFILE4,270)
  270 FORMAT(/45H *************************************                )
      WRITE (IFILE4,280)
  280 FORMAT(/50H VALUES OF VARIOUS VARIABLES AND STORAGE REQUIRED     )
      WRITE (IFILE4,290)
  290 FORMAT(/50H VARIABLE   VALUE             DEFINITION             /)
      WRITE (IFILE4,300)I2
      WRITE (IFILE4,310)M2
      WRITE (IFILE4,320)IBLKP
      WRITE (IFILE4,330)IMAXP
      WRITE (IFILE4,340)M3
      WRITE (IFILE4,350)IBLK
      WRITE (IFILE4,360)IMAXB
      WRITE (IFILE4,370)ILONG
      WRITE (IFILE4,380)ITSTOR
      WRITE (IFILE4,390)ITHSTR
      WRITE (IFILE4,400)IZSTOR
      WRITE (IFILE4,410)JBEGIN
      WRITE (IFILE4,420)KBEGIN
      WRITE (IFILE4,430)LBEGIN
      WRITE (IFILE4,270)
      WRITE (IFILE4,440)L1
      WRITE (IFILE4,450)L2
      WRITE (IFILE4,460)L3
      WRITE (IFILE4,470)L4
      WRITE (IFILE4,480)L5
      WRITE (IFILE4,490)L6
      WRITE (IFILE4,500)L7
      WRITE (IFILE4,510)
      WRITE (IFILE4,270)
      WRITE (IFILE4,270)
      IF (I2.GT.2000) THEN
         WRITE(IFILE4,4222) I2
 4222    FORMAT(//' ******************* NOTE ******************'/
     1' ***********************************************'//
     1' TOTAL NUMBER OF FINITE ELEMENTS IN THE MODEL =',I5/
     1' THE MAXIMUM ALLOWABLE IS 2000. PLEASE REDUCE YOUR MODEL SIZE.')
        CALL ERREX
      ENDIF
C
  300 FORMAT(7H     I2 I6,   ' TOTAL NUMBER OF FINITE-DIFFERENCE ELEMENT
     1S IN THIS CASE'                                                  )
  310 FORMAT(7H     M2 I6,   ' TOTAL NUMBER OF EQUATIONS IN PREBUCKLING
     1ANALYSIS'                                                        )
  320 FORMAT(7H  IBLKP I6,   ' NO. OF BLOCKS INTO WHICH PREBUCKLING EQUA
     1TIONS ARE DIVIDED FOR FACTORING AND SOLVING'                     )
  330 FORMAT(7H  IMAXP I6,   ' MAXIMUM SIZE OF EACH BLOCK OF PREBUCKLING
     1 EQUATIONS'                                                      )
  340 FORMAT(7H     M3 I6,   ' NUMBER OF EQUATIONS IN STABILITY ANALYSIS
     1 '                                                               )
  350 FORMAT(7H   IBLK I6,   ' NO. OF BLOCKS INTO WHICH STABILITY EQUATI
     1ONS MUST BE DIVIDED FOR FACTORING AND SOLVING'                   )
  360 FORMAT(7H  IMAXB I6,   ' MAXIMUM SIZE OF EACH BLOCK OF THE STABILI
     1TY EQUATIONS'                                                    )
  370 FORMAT(7H  ILONG I6,   ' TOTAL NUMBER OF PLACES FOR WHICH PLASTIC
     1AND CREEP EFFECTIVE STRAINS AND YIELD STRESS ARE CALCULATED'     )
  380 FORMAT(7H ITSTOR I6,   ' LENGTH OF ARRAY FOR TEMPERATURE CALLOUTS
     1IN SHELL SEGMENTS'                                               )
  390 FORMAT(7H ITHSTR I6,   ' LENGTH OF ARRAY FOR THICKNESS CALLOUTS
     1IN SHELL SEGMENTS'                                               )
  400 FORMAT(7H IZSTOR I6,   ' LENGTH OF ARRAY FOR REFERENCE SURFACE CAL
     1LOUTS IN SHELL SEGMENTS'                                         )
  410 FORMAT(7H JBEGIN I6,   ' LENGTH OF ARRAY FOR TEMPERATURE CALLOUTS
     1IN DISCRETE RINGS'                                               )
  420 FORMAT(7H KBEGIN I6,   ' LENGTH OF ARRAY FOR STRESS-STRAIN PROPERT
     1IES IN DISCRETE RINGS'                                           )
  430 FORMAT(7H LBEGIN I6,   ' LENGTH OF ARRAY FOR PLASTIC STRAINS, CREE
     1P STRAINS, YIELD STRESS IN DISCRETE RINGS'                       )
  440 FORMAT(7H     L1 I7,   ' WORKING SPACE REQUIRED IN APREB
     1 (PREBUCKLING EQUATIONS SET UP)'                                 )
  450 FORMAT(7H     L2 I7,   ' WORKING SPACE REQUIRED IN SOLN
     1 (PREBUCKLING EQUATIONS SOLVED)'                                 )
  460 FORMAT(7H     L3 I7,   ' WORKING SPACE REQUIRED IN PRE22
     1 (PREBUCKLING DISPLACEMENTS, STRESSES, STRAINS CALC.)'           )
  470 FORMAT(7H     L4 I7,   ' WORKING SPACE REQUIRED IN PRE33
     1 (PLASTIC AND CREEP STRAINS, YIELD STRESS CALCULATED)'           )
  480 FORMAT(7H     L5 I7,   ' WORKING SPACE REQUIRED IN ARRAYS
     1 (STABILITY EQUATIONS SET UP)'                                   )
  490 FORMAT(7H     L6 I7,   ' WORKING SPACE REQUIRED IN ARRAYS
     1 (STABILITY DETERMINANT CALCULATED IF INDIC=-2)'                 )
  500 FORMAT(7H     L7 I7,   ' WORKING SPACE REQUIRED IN BUCKLE
     1 (EIGENVALUES CALCULATED)'                                       )
  510 FORMAT(/50H ***NOTE THAT L1-L7 MUST NOT EXCEED 160000 *****      )
      WRITE (IFILE4,270)
C
      DO 530 I = 1,297
  530 VSAVE(I) = V(I)
C
      RETURN
C     RETURN CARD NOT NEEDED IN CDC VERSION
      END
C=DECK      TLOAD
      SUBROUTINE TLOAD(STEP,FLOAD,TOME,INDEX)
C
C     THIS SUBROUTINE CALCULATES FLOAD, GIVEN STEP AND TOME
C
C     STEP = INDEX FOR CHOOSING TYPE OF TIME DEPENDENCE OF LOAD
C     TOME = ELAPSED TIME SINCE BEGINNING OF CASE
C     FLOAD = VALUE OF THE PARTICULAR FUNCTION OF TIME WHICH THIS
C             PARTICULAR LOAD ASSUMES AT TIME T = TOME (ACTUALLY,
C             THE LOAD IS GIVEN BY AN AMPLITUDE FACTOR TIMES FLOAD.
C
C
      COMMON/TLOADS/FTLOAD(100,2),NTIME(11),ITIME
      FLOAD = 0.0
      ITYPE = STEP
      IF (INDEX.EQ.0) GO TO 10
      IF (ITYPE.GT.10.OR.ITYPE.EQ.0) GO TO 60
   10 I1 = ITYPE + 1
      N1 = NTIME(I1)
      NPOS = 0
      IF (ITYPE.EQ.0) GO TO 30
      DO 20 I=1,ITYPE
   20 NPOS = NPOS + NTIME(I)
   30 DO 40 I=2,N1
      NPOS1 = NPOS + I
      T2 = FTLOAD(NPOS1,2)
      IF (TOME.LT.T2) GO TO 50
   40 CONTINUE
   50 NPOSM = NPOS1 - 1
      T1 = FTLOAD(NPOSM,2)
      F1 = FTLOAD(NPOSM,1)
      F2 = FTLOAD(NPOS1,1)
      T21 = T2-T1
      FLOAD = F1
      IF (T21) 55,60,55
   55 CONTINUE
      FLOAD = (F2- F1)*(TOME - T1)/(T2- T1) + F1
   60 CONTINUE
      RETURN
      END
