C=DECK      MAINLIB
C
C  THIS IS THE MAIN LIBRARY (SOURCE FILE)
C
C
C
C=DECK      MAIN
      PROGRAM MAIN
C
C     MAIN PROGRAM FOR BOSOR5
C
C  200-SEGMENT VERSION OF BOSOR5
C        GLOSSARY OF PROGRAM VARIABLES.  '*' MEANS AN INPUT VARIABLE
C    *   MARGIN -  TIME LEFT BEFORE MAX TIME CUTOFF (IN SECONDS)
C        NBEGIN -  NOT USED
C    *   INDIC  -  ANALYSIS CONTROL INTEGER. . .
C                       INDIC = 0 MEANS AXISYMMETRIC STRESS ANALYSIS
C                       INDIC =-2 MEANS STABILITY ANALYSIS WITH
C                                 CALCULATION OF PREBUCKLING BEHAVIOR
C                                 FOR A SEQUENCE OF TIME STEPS UNTIL
C                                 STABILITY DETERMINANT CHANGES SIGN.
C                                 THEN INDIC IS AUTOMATICALLY CHANGED
C                                 TO - 1.
C                       INDIC =-1 MEANS CALCULATE EIGENVALUES FOR RANG
C                                 OF CIRCUMFERENTIAL WAVENUMBER,N
C                       INDIC =-3 MEANS CALCULATE STABILITY DETERMINANT
C                                 FROM PREBUCKLING DATA STORED ON DRUM
C                                 BY PREVIOUS RUN OR RUNS.
C        IFLOW  -  NOT USED
C    *   ICREEP -  1 MEANS YES, THERE IS CREEP.  0 MEANS NO CREEP
C        IJNCT  -  USED IN BOSOREAD. NOT RELEVANT IN THIS LINK.
C        IJNTB  -  USED IN BOSOREAD. NOT RELEVANT IN THIS LINK
C        ITSTOR -  LENGTH OF TEMPERATURE DATA ARRAY
C        ITHSTR -  LENGTH OF THICKNESS DATA ARRAY
C        IZSTOR -  LENGTH OF REFERENCE SURFACE CALLOUT ARRAY
C        IBSTOR -  ITSTOR + ITHSTR + IZSTOR + I2 (SEE I2)
C        RC(99) -  RADII OF DISCRETE RINGS, MEASURED TO CENTROIDS
C    *   KSTEP  -  TIME STEP NUMBER.
C        KSTEPM -  NOT USED
C        N      -  NUMBER OF CIRCUMFERENTIAL WAVES IN BUCKLING OR
C                  VIBRATION PATTERN
C        TOMES  -  TIME AT PREVIOUS TIME STEP
C        NTOT   -  TOTAL NUMBER OF DISCRETE RINGS IN STRUCTURE
C        IPRE   -  NUMBER OF PIECES OF DATA STORED FOR EACH DISCRETE
C                  RING, NOT INCLUDING MATERIAL PROPS. OR PLASTIC
C                  OR CREEP STRESSES OR STRAINS
C    *   NCOND  -  NUMBER OF BOUNDARY AND JUNCTURE AND OTHER CONSTRAINT
C                  POINTS FOR AXISYMMETRIC STRESS ANALYSIS
C        M3     -  NUMBER OF EQUATIONS IN STABILITY OR VIBRATION PROBS.
C        IWAL() -  IDENTIFIERS FOR CERTAIN DATA STORED ON DRUM
C    *   NBEG(I)-  OUTPUT PRINTED STARTING AT NBEG(I)TH POINT IN ITH
C                  SEGMENT
C    *   NSTOPP(I)-OUTPUT PRINTED FROM NBEG(I) TO NSTOPP(I) IN ITH SEG.
C    *   INTVAL(I)-OUTPUT PRINTED FOR EVERY INTVAL(I)TH TIME STEP IN
C                  ITH SEGMENT
C        NWORD(I) -CERTAIN DATA ON NUMBER OF LAYERES, TEMPERATURE DIST.,
C                  TYPE OF MATERIAL, ETC. PACKED INTO NWORD(I) FOR ITH
C                  SEGMENT
C    *   NPLAST(I)-1 MEANS THIS ITH SEGMENT IS ELASTIC-PLASTIC,
C                  0 MEANS THAT THIS ITH SEGMENT IS ELASTIC ONLY.
C    *   NCREEP(I)-1 MEANS THIS ITH SEGMENT CREEPS, 0-NO CREEP
C    *   NMAT(I) - MATERIAL TYPE FOR ITH SEGMENT
C    *   NALRED(I)-MATERIAL PROPS FOR ITH SEGMENT HAVE ALREADY BEEN READ
C    *   NALRED(I)-1 MEANS THAT THE MATERIAL PROPERTIES OF THIS SEGMENT
C                  ARE THE SAME AS THOSE ALREADY GIVEN FOR A PREVIOUS
C                  SEGMENT.
C                  0 MEANS THAT THE MATERIAL PROPERTIES OF THE ITH
C                  SEGMENT WILL NEED TO BE READ IN BECAUSE THEY ARE
C                  DIFFERENT FROM THOSE GIVEN FOR PREVIOUS SEGMENTS.
C    *   NSEG   -  NUMBER OF SEGMENTS IN ENTIRE STRUCTURE
C        M2     -  NUMBER OF EQUATIONS IN AXISYMMETRIC PREBUCKLING ANAL.
C    *   I5(I)  -  NUMBER OF 'W' MESH POINTS IN ITH SEGMENT
C        I2     -  TOTAL NUMBER OF 'W' MESH POINTS IN ENTIRE STRUCTURE
C        NFAIL  -  1 MEANS THAT NEWTON-RAPHSON ITERATIONS HAVE NOT CON-
C                  VERGED
C                  0 MEANS THAT THEY HAVE CONVERGED.
C        ITER   -  CURRENT NUMBER OF THIS NEWTON-RAPHSON ITERATION
C        IBLK   -  NUMBER OF BLOCKS INTO WHICH THE STABILITY STIFFNESS
C               MATRIX MUST BE DIVIDED FOR PROBLEM TO FIT INTO CORE
C        NGBK(I)-  EQUATION NUMBER OF LAST EQUATION IN ITH BLOCK
C        NKF(I) -  I'VE FORGOTTEN WHAT THIS IS. ITH BLOCK
C        IMAXP  -  MAXIMUM PERMITTED STORAGE SIZE OF EACH BLOCK OF THE
C                  STIFFNESS MATRIX FOR AXISYMMETRIC PREBUCKLING PROB.
C        IMAXB  -  MAXIMUM PERMITTED STORAGE FOR EACH BLOCK OF THE
C                  STABILITY OR VIBRATION MATRICES
C        KMAXP(I)- MAXIMUM BANDWIDTH OF ITH BLOCK OF PREBUCKLING MATRIX
C        KMAXB(I)- MAXIMUM BANDWIDTH OF ITH BLOCK OF STABILITY MATRIX
C        IBLKP  -  NUMBER OF BLOCKS  THAT AXISYMMETRIC PRESTRESS PROBLEM
C                  STIFFNESS MATRIX MUST BE DIVIDED INTO FOR PROBLEM TO
C                  FIT INTO CORE
C        NGBKP(I)- EQUATION NUMBER OF LAST EQ. IN ITH BLOCK
C        NKFP(I) - I'VE FORGOTTEN WHAT THIS IS, ITH BLOCK
C        ILOCP  -  IDENTIFIER FOR DISK STORAGE OF ILOC ARRAY FOR PRESTR
C                  ESS PROBLEM
C        ILOCB  -  SAME AS FOR ILOCP, EXCEPT PERTAINS TO STABILITY PROB
C        IROWCP(I)-ROW NO. OF CONSTRAINT CONDITION, PREBUCKLING PROBLEM
C        IROWCB(I)-SAME AS FOR IROWCP(I), EXCEPT PERTAINS TO STABILITY
C        IIWP   -  IDENTIFIER FOR DISK STORAGE OF IW ARRAY, PRESTRESS
C        IIWB   -  SAME AS IIWP, EXCEPT PERTAINS TO STABILITY PROBLEM
C    *   ISEGA  -  FIRST SEGMENT FOR WHICH STABILITY ANALYSIS IS PERFORM
C    *   ISEGA  -  STABILITY ANALYS
C    *   ISEGA  -  STABILITY ANALYSIS IS PERFORMED FOR SHELL SEGMENTS
C                  ISEGA THROUGH ISEGB
C    *   ISEGB  -  SEE DEFINITIAON OF ISEGA
C    *   NCONDB -  NUMBER OF CONSTRAINT POINTS IN STABILITY PROBLEM
C    *   ISTOP0()- CONTROL INTEGERS FOR PREVENTION OF RIGID BODY AXISYM-
C                  METRIC DISPLACEMENTS
C    *   ISTOP1()- CONTROL INTEGERS FOR PREVENTION OF RIGID BODY MOTION
C                  CORRESPONDING TO ONE CIRCUMFERENTIAL WAVE
C    *   NREGNS -  NUMBER OF REGIONS IN WHICH PRESTRESS IS SET EQUAL TO
C                  ZERO BEFORE STABILITY ANALYSIS IS PERFORMED
C    *   IREGN(10,2)- DELIMITERS FOR REGIONS IN WHICH PRESTRESS IS SET
C                  EQUAL TO ZERO IN STABILITY ANALYSIS
C        ITTURE(I)-PERTAINS TO TEMPERATURE CALLOUTS IN ITH SEGMENT
C        IDEPTH(I)-PERTAINS TO THICKNESS CALLOUTS IN ITH SEGMENT
C        IREFZ(I)- PERTAINS TO REFERENCE SURFACE CALLOUTS IN ITH SEGMENT
C        ILONG  -  NUMBER OF STATIONS FOR WHICH PLASTIC STRAINS, ETC.
C                  ARE SAVED.
C        IDZ    -  I DON'T THINK IT'S USED ANYMORE, BUT NOT SURE
C        IZRING(I)-CALLOUT FOR GLOBAL AXIAL STATION OF ITH DISCRETE RING
C        ISAVE(20)-NOT USED ANYMORE
C        INOTE  -  NOT USED ANYMORE
C        JBEG(I)-  LOCATION IN AN ARRAY OF TEMPERATURE DATA FOR ITH
C                  DISCRETE RING
C        KBEG(I) - LOCATION IN ARRAY OF STRESS-STRAIN DATA FOR ITH RING
C        NPOINT(I)-NUMBER OF POINTS USED FOR SPECIFYING THE STRESS-
C                  STRAIN CURVE FOR THE ITH KIND OF DISCRETE RING MAT'L
C        NSUM1(I)- PACKED WORD FOR DESCRIPTION OF ITH DISCRETE RING
C                  SEGMENT
C        NSUM2(I)- SAME AS FOR NSUM1(I), EXCEPT DIFFERENT DESCRIPTORS
C    *   NTYP(I) - TYPE OF DISCRETE RING--0= FAKE RING, 6 = REAL RING
C    *   NPARTS(I)-NUMBER OF SEGMENTS IN ITH DISCRETE RING
C    *   TITLE(12)-ALPHANUMERIC TITLE OF CASE
C    *   D1B(I) -  RADIAL DISCONTINUITY BETWEEN TWO SHELL SEGMENTS. THIS
C                  VALUE WILL BE USED IN THE STABILITY ANALYIS
C    *   D2B(I) -  AXIAL DISCONTINUITY BETWEEN SHELL SEGMENTS. THIS
C                  VALUE WILL BE USED IN STABILITY ANALYSIS
C    *   D1(I)  -  RADIAL DISCONTINUITY BETWEEN SHELL SEGMENTS, TO BE
C                  USED IN AXISYMMETRIC EQUILIBRIUM ANALYSIS
C    *   D2(I)  -  AXIAL DISCONTINUITY BETWEEN SHELL SEGMENTS, TO BE
C                  TO BE USED IN AXISYMMETRIC STRESS ANALYSIS
C    *   NVEC  -   NUMBER OF EIGENVALUES TO BE CALCULATED FOR EACH N
C        EGV(I) -  EIGENVALUES FOR EACH N ARE STORED HERE
C    *   AXB   -   INITIAL SHIFT FOR INVERSE POWER ITERATIONS
C    *   FTLOAD(I,J)-FUNCTIONS OF TIME. LOADS VARY ACCORDING TO THESE
C                  DATA
C    *   NTIME(I) -NUMBER OF TIME CALLOUTS FOR LOAD AS A FUNCTION OF
C                  TIME FOR ITH KIND OF LOAD TIME-VARIATION
C    *   TOME   -  CURRENT TIME
C    *   DTIME  -  TIME INCREMENT, EITHER READ IN OR COMPUTED, DEPENDING
C                  ON VALUE OF ITIME
C        IPMODE(I)-DISK STORAGE LOCATION OF PREBUCKLING SOLUTION VECTOR
C                  FOR ITH TIME STEP. NOTE THAT ONLY 25 STEPS PERMITTED
C        ICMODE(I)-DISK STORAGE LOCATION OF C(I,J),THERM(I,J),RING(),
C                  FOR ITH TIME STEP
C        ISMODE(I)-DISK STORAGE LOCATION OF PLASTIC STRAIN,CREEP STRAIN,
C                  EFFECTIVE STRAIN, YIELD STRESS, FOR ITH TIME STEP
C        IQMODE(I)-DISK STORAGE LOCATION OF PREBUCKLING RESULTANTS, ITH
C                  TIME STEP
C        IHMOD(I) -DISK STORAGE LOCATION OF SHEAR COEFFICIENTS, ITH TIME
C                  STEP
C    *   N0B    -  INITIAL CIRCUMFERENTIAL WAVE NUMBER, STABILITY PROBLE
C    *   NMINB  -  MINIMUM CIRC. WAVE NUMBER FOR CALCUAATION OF EIGENVAL
C    *   NMAXB  -  MAXIMUM CIRC. WAVENUMBER FOR BUCKLING LOADS
C    *   INCRB  -  INCREMENT IN CIRC. WAVES TO USE IN STABILITY ANALYSIS
C    *   ITMAX  -  MAXIMUM NUMBER OF NEWTON ITERATIONS BEFORE EXIT CALL
C        DET   -   STABILITY DETERMINANT
C        NEX   -   EXPONENT FOR STABILITY DETERMINANT
C     ITIME = IF ITIME = 0, TIME INCREMENT CALCULATED
C             IF ITIME = 1, TIME INCREMENT, DTIME, READ IN
C
C        B(160000)-WORKING SPACE. IF YOU WANT TO OCCUPY LESS CORE,REDUCE
C       DB(80000) -WORKING SPACE. IF YOU WANT TO OCCUPY LESS CORE,REDUCE
C                  HOWEVER, THE DIMENSION OF DB MUST BE HALF THAT OF B.
C
C
C
C     OVERLAY(BMAIN,0,0)
C     PROGRAM MAIN(INPUT,OUTPUT,TAPE5=INPUT,TAPE6=OUTPUT, ETC,ETC...)
C
#if hp700
$hp9000_800 intrinsics
#endif
C BEG DEC 2005
      DIMENSION FTIME(200),FDISP(200)
C BEG AUG 2005
C BEG FEB 2008
      COMMON/WPREMY/WPREMX,WPRALL,ENDUV
      DIMENSION FDISP2(200)
C END FEB 2008
      COMMON/EPSEFX/EPSMAX(201,100,1),EPSMXX(201)
      COMMON/ORTHP2/SMM(20),EPSALL(20)
      DIMENSION EPSRAT(201)
      CHARACTER*16 WRDMAT
C END AUG 2005
      COMMON/MATP2/ETAN(20,9),MAXTRL,ITRIAL,EMAX(9),ATWEEN(95),SBRDF(95)
      COMMON/TIMLFT/MARGIN,NBEGIN
      COMMON/INSTAB/INDIC
      COMMON/IFLOWS/IFLOW,ICREEP,IJNCT,IJNTB,ITSTOR,ITHSTR,IZSTOR,IBSTOR
      COMMON/RINGRD/RC(99)
      COMMON/FLSTEP/KSTEP,KSTEPM
      COMMON/WAVES/N
      COMMON/SVTOM/TOMES
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/NCONDS/NCOND
      COMMON/TOTPTS/M3
      COMMON/SHEL/IWAL(201)
      COMMON/NBGSTP/NBEG(201),NSTOPP(201) ,INTVAL(201)
      COMMON/THERWD/NWORD(201),NPLAST(201),NCREEP(201),NMAT(201),
     1              NALRED(201)
      COMMON/SEGS/NSEG,M2,I5(201),I2,NFAIL
      COMMON/ITERS/ITER
      COMMON/BLK/IBLK,NGBK(20),NKF(20)
      COMMON/BKSIZE/IMAXP,IMAXB,KMAXP(20),KMAXB(20)
      COMMON/BLKP/IBLKP,NGBKP(20),NKFP(20)
      COMMON/LOCATN/ILOCP,ILOCB,IROWCP(201),IROWCB(201),IIWP,IIWB
      COMMON/SEGBND/ISEGA,ISEGB,I2AB,NCONDB
      COMMON/RBODY/ISTOP0(6),ISTOP1(6)
      COMMON/ZREGNS/NREGNS,IREGN(10,2)
      COMMON/IGOVN/ITTURE(201),IDEPTH(201),IREFZ(201),ILONG
      COMMON/GLOBAL/IDZ,IZRING(99),ISAVE(20),INOTE
      COMMON/RPLST4/JBEG(99),KBEG(10),NPOINT(10) ,NSUM1(199),NSUM2(199)
      COMMON/RPLST5/NTYP(99),NPARTS(99)
      COMMON/HED/TITLE(12)
      COMMON/RING4/D1B(201),D2B(201)
      COMMON/RING3/D1(201),D2(201)
      COMMON/EIGNO/NVEC,EGV(50),AXB
      COMMON/TLOADS/FTLOAD(100,2),NTIME(11),ITIME
      COMMON/TOMER/TOME,DTIME
      COMMON/SMODE/IPMODE(99),ICMODE(99),ISMODE(99),IQMODE(99),IHMOD(99)
      COMMON/BUCKN/N0B,NMINB,NMAXB,INCRB
      COMMON/MAXIT/ITMAX
      COMMON/DETER/DET,NEX
      COMMON/KKSSP/KMIN,KMAX
      COMMON/IDEIG/IVEC(50),NTRY
      COMMON/AUXSTO/IDD,ISER,ILAST,ICUR,ISTAT
      COMMON/IDEFOM/INDEXX
      COMMON/BUCKEG/BLOAD(100)
      COMMON/ECFFI/TPAST(100)
      COMMON/OUTP/NPRT
      COMMON/     /B(160000)
      COMMON/SIGNALL/ISIG,KKKK,NSTEPS,LSTEPS(50),TIMES(51)
      COMMON/ISNL/ISIGNL
      COMMON/CONPRE/CPRE
      COMMON/CDATA/TFLOOR,CREEPN(9),CREEPM(9),CREEPA(9),CREEPB(9)
      COMMON/CHGBND/IICHNG,TCHANG(10),SBARCH(10)
      COMMON/ITOTLL/ITOTL,PLPNT(2000,2),E1MAX,E2MAX
      COMMON/IPLINX/IPLIND
      COMMON/IDHIGH/IDMAX
      COMMON/NONCON/NOCONV
      COMMON/DELOAD/IELAST
      COMMON/INDAT/INFILE
      CHARACTER*4 ANSOUT
      CHARACTER*4 CHARAC
      integer outfile, stofile
      LOGICAL ANSL1
      logical exists
      DOUBLE PRECISION DB
#if cray
      DIMENSION DB(160000)
#else
      DIMENSION DB(80000)
#endif
      DIMENSION IB(650)
      EQUIVALENCE (B(1),DB(1)),(B(1),IB(1))
      common/case/casename
      character*28 casename
      character*32 fname
C BEG FEB 2009
#if hp700
C     call getarg(2, casename)
      call getarg(1, casename)
#else
      call getarg(1,casename)
#endif
C END FEB 2009
      CALL MAIN1
C
C        EACH OF THE SUBROUTINES GETCOM, LOADS, PRE11,PRE22,PRE33,
C        ARRAYS, AND BUCKLE IS IN A SEPARATE OVERLAY.
C
C    SUBROUTINE GETCOM --  READS STUFF INTO CORE TO BE USED IN THIS ANAL
C                           YSIS
C
C     GETCOM READS STUFF FROM PERMANENT STORAGE PUT THERE BY READIT.
C
C     CALL OVERLAY(5HBMAIN,1,0)     (CDC VERSION)
C
      stofile = 9
      fname = casename(1:index(casename, ' ')-1)//'.BLK'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='OLD')
#if rs6k
        rewind(stofile)
#endif
      else
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='NEW')
      endif
      CALL GETCOM
      close(stofile)

C BEG JAN 2012
c     open the EXUSTING database

      CALL GASP(DUM1,DUM2,0,DUM3)

C END JAN 2012
c
      WRITE(6,4) (TITLE(I),I=1,12)
    4 FORMAT(1X,12A4)
      CALL SR100T(1)
      AXB = 0.0
      DET = 1.0
      ISIG = 0
      KMIN = 1
      NTRY = 1
      INDEXX = 0
      KSTEPM = 0
      ISIGNL = 0
C BEG DEC 2005
      FTIME(1) = 0.
      FDISP(1) = 0.
C END DEC 2005
C BEG FEB 2008
      FDISP2(1) = 0.
C END FEB 2008
      SBARCH(1) = 1.E+30
      TCHANG(1) = 1.E+30
      DO 3 I = 1,NSEG
    3 INTVAL(I) = 100
      NVEC = 1
      NPRT = 0
      IICHNG = 0
      IFILE = 2
      IFILE3 = 7
      INFILE = 5
c Begin May 1990 quick-fix
      outfile = 29
c End May 1990 quick-fix
C
C
C
C FOLLOWING USED FOR VAX/VMS..
c     OPEN(UNIT=IFILE,FILE='BOSOR5:PROMPT.DAT',STATUS='OLD',READONLY)
c     OPEN(UNIT=IFILE3,FILE='BOSOR5:PROMPT3.DAT',STATUS='OLD',READONLY)
C END VAX/VMS OPEN STATEMENTS
C
C FOLLOWING USED FOR UNIX...
      OPEN(UNIT=IFILE,FILE='PROMPT.DAT',STATUS='OLD')
      OPEN(UNIT=IFILE3,FILE='PROMPT3.DAT',STATUS='OLD')
#if rs6k
      rewind(IFILE)
      rewind(IFILE3)
#endif
c Begin May 1990 quick-fix
      open(unit=outfile, status='SCRATCH')
c End May 1990 quick-fix
C END UNIX OPEN STATEMENTS
C
C
      CALL DATUM(IFILE,2,1,2,INDIC,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,3,1,4,INT,REALL,ANSOUT,outfile,0,1)
      CALL DATUM(IFILE,5,1,2,IFLOW,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,6,1,2,ICPRE,REALL,CHARAC,outfile,0,1)
      CPRE =ICPRE
C     CPRE = 0. IF PREFIX SUBTRACTED FROM PREVAR IN STAB. EQS.
C     CPRE = 1. IF PREFIX NOT SUBTRACTED FROM PREVAR IN STAB. EQS.
C
      IF (INDIC.NE.-3) GO TO 10
      KKKK = 0
      CALL DATUM(IFILE,13,1,2,NSTEPS,REALL,CHARAC,outfile,0,1)
      DO 5 I = 1,NSTEPS
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE,14,1,2,LSTEPS(I),REALL,CHARAC,outfile,I,IPROMP)
    5 CONTINUE
C
      DO 6 I = 1,NSTEPS
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE,15,1,1,INT,TIMES(I),CHARAC,outfile,I,IPROMP)
    6 CONTINUE
C
      TIMES(NSTEPS+1) = TIMES(NSTEPS)
      KMAX = LSTEPS(NSTEPS)
      KMIN = LSTEPS(1)
      ISIG = 1
      INDIC = -2
      GO TO 30
   10 CONTINUE
C
C
      ISTRAT = 0
      IELAST = 0
      REWIND IFILE3
      CALL DATUM(IFILE3,490,1,2,INT,REALL,ANSOUT,outfile,0,1)
      IF (ANSL1('N',ANSOUT,INFILE)) GO TO 15
      CALL DATUM(IFILE3,494,0,0,INT,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE3,496,1,2,ISTRAT,REALL,CHARAC,outfile,0,1)
   15 CONTINUE
      REWIND IFILE
      CALL DATUM(IFILE,7,1,2,KSTEP,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,8,1,2,KMAX,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,9,1,2,MAXTRL,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,11,1,2,ITMAX,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,12,1,2,ITIME,REALL,CHARAC,outfile,0,1)
      IF (ISTRAT.EQ.1) ITIME = 1
      IF (ISTRAT.NE.0) GO TO 17
      CALL DATUM(IFILE,16,1,2,INT,REALL,ANSOUT,outfile,0,1)
      IF (ANSL1('Y',ANSOUT,INFILE)) IELAST = 1
   17 CONTINUE
      IF (ISTRAT.EQ.2) IELAST = 1
C
      MARGIN = 0
      KMIN = KSTEP + 1
      IF (KSTEP.EQ.0) GO TO 30
      N2 = 3*M2 + 3
      CALL GASP(B(N2),M2,3,IPMODE(KSTEP))
      M32 = 3*M2 + 2
      CALL GASP(B(1),M32,3,IWAL(15))
      DO 20 I=1,M2
      I1D = (M2 + 1)/2 + I
      I22 = N2 + I - 1
   20 DB(I1D) = B(I22)
      CALL GASP(B(1),M32,1,IWAL(15))
   30 CONTINUE
      IF (INDIC.EQ.0) GO TO 60
C
      CALL DATUM(IFILE,17,1,2,N0B,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,18,1,1,NMINB,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,19,1,1,NMAXB,REALL,CHARAC,outfile,0,1)
      CALL DATUM(IFILE,20,1,2,INCRB,REALL,CHARAC,outfile,0,1)
C
      IF (INCRB.EQ.0) INCRB = 1
      N = NMINB
      IF (INDIC.EQ.-2) N = N0B
      WRITE (6,40)N0B,NMINB,NMAXB,INCRB
   40 FORMAT(40H INITIAL BUCKLING OR VIBRATION WAVE NO.= I6,19H, MINIMUM
     1 WAVE NO.= I6,19H, MAXIMUM WAVE NO.= I6,12H, INCREMENT=  I6//)
      WRITE (6,50)NVEC
   50 FORMAT(2X,I3,57H EIGENVALUES SOUGHT FOR EACH CIRCUMFERENTIAL WAVE
     1NUMBER.   //)
   60 CONTINUE
      IF (INDIC.EQ.-1.OR.ISIG.EQ.1) GO TO 110
      CALL DATUM(IFILE,21,1,2,INT,TOME,CHARAC,outfile,0,1)
      IF (ITIME.EQ.1) CALL DATUM(IFILE,22,1,2,INT,DTIME,CHARAC,outfile,
     1  0,1)
      IF (IICHNG.GT.0) READ(5,70) TCHANG(1),SBARCH(1),CREEPN(9),
     1 CREEPM(9),CREEPA(9),CREEPB(9)
      IF (MAXTRL.EQ.0) MAXTRL = 1
   70 FORMAT(6E12.8)
   80 FORMAT(10I6)
C
      IPLIND = 0
      CALL DATUM(IFILE,23,1,2,INT,REALL,ANSOUT,outfile,0,1)
      IF (ANSL1('Y',ANSOUT,INFILE)) IPLIND = 1
C
   90 CONTINUE
C
C    SUBROUTINE LOADS - TIME STEP IS ADDED TO TOME, AND NEW LOADS ARE
C                       COMPUTED FROM TIME FUNCTIONS FTLOAD(I,J)
      CALL LOADS
C
C     CALL OVERLAY(5HBMAIN,2,0)      (CDC VERSION)
C
      IF (KSTEP.GT.KMAX) GO TO 130
      ITRIAL = 0
  100 CONTINUE
      ITRIAL = ITRIAL + 1
C
C    SUBROUTINE PRE11-- THE PREBUCKLING SOLUTION FOR THE CURRENT TRIAL
C                       IS FOUND HERE. MATERIAL PROPERTIES ARE FIXED IN
C                       PRE11.  NONLINEAR ALGEBRAIC EQUATIONS ARE SOLVED
C                       WITH USE OF THE NEWTON-RAPHSON METHOD
C
      NOCONV = 0
      CALL PRE11
      CALL SR100T(2)
      IF (NOCONV.EQ.1) GO TO 160
      IF (KSTEPM.EQ.0) GO TO 105
      KSTEP = KSTEP - 2
      CALL LOADS
      GO TO 115
  105 CONTINUE
C
C     CALL OVERLAY(5HBMAIN,3,0)   (CDC VERSION)
C
      IF (ITRIAL.EQ.MAXTRL) ITER = 1
      IF (MAXTRL.LE.5) GO TO 108
      IF (ITRIAL.LT.MAXTRL) GO TO 108
      WRITE(6,106)
      WRITE(6,106)
      WRITE(6,106)
      WRITE(6,106)
  106 FORMAT(' *****************************************************')
      WRITE(6,107) TOME, KSTEP
  107 FORMAT(/' MATERIAL PROPERTIES HAVE TROUBLE CONVERGING FOR THIS TIM
     1E STEP..(TOME = '1PE13.4,'  , LOAD STEP NO.'I3, ').'/' IT MIGHT BE
     2 NECESSARY TO TAKE SMALLER TIME/LOAD INCREMENTS IN A RESTART.'/)
      WRITE(6,106)
      WRITE(6,106)
      WRITE(6,106)
      WRITE(6,106)
  108 CONTINUE
C
C    SUBROUTINE PRE22-- DISPLACEMENTS AND STRAINS ARE CALCULATED FROM
C                       THE SOLUTION VECTOR FOUND IN PRE11.
      CALL PRE22
C
C     CALL OVERLAY(5HBMAIN,4,0)   (CDC VERSION)
C
C
C    SUBROUTINE PRE33-- NEW VALUES ARE CALCULATED FOR THE PLASTIC AND
C                       CREEP STRAINS, YIELD STRESS, EFFECTIVE STRAIN,
C                       AND INTEGRATED CONSTITUTIVE LAW, C(I,J). NEW
C                       MATERIAL PROPERTIES ARE ALSO CALCULATED FOR THE
C                       ELASTIC-PLASTIC DISCRETE RINGS.
      CALL PRE33
C
C     CALL OVERLAY(5HBMAIN,5,0)   (CDC VERSION)
C
      IF (ITER.GT.1) GO TO 100
      IF (IPLIND.GT.0) CALL LISTPL(NSEG,I5) 
C BEG AUG 2005
C Print out maximum effective uniaxial strain...
      DO 210 ISEG = 1,NSEG
         I5I = I5(ISEG)
         EPSMXX(ISEG) = 0.0
         DO 205 IPOINT = 1,I5I
            EPSMXX(ISEG) = 
     1       MAX(EPSMXX(ISEG),EPSMAX(ISEG,IPOINT,1))
  205    CONTINUE
         WRDMAT =                          ' material ok    '
         EPSRAT(ISEG) = 10.E+16
         IF (EPSMXX(ISEG).GT.0.0)
     1   EPSRAT(ISEG) = ABS(EPSALL(1))/EPSMXX(ISEG)
         IF (EPSRAT(ISEG).LT.1.0) WRDMAT = ' material failed'
         EPSMAR = EPSRAT(ISEG) - 1.0
         WRITE(6,'(A,I4,A,1P,E12.4,A,A,1P,E12.4)')
     1 ' Seg.',ISEG,'; Max.eff.strain(%)=',EPSMXX(ISEG),
     1   WRDMAT,'; strain margin=',EPSMAR
  210 CONTINUE
         WPRMAR = 10.E+16
         IF (WPREMX.GT.0.0) 
     1         WPRMAR = ABS(WPRALL)/ABS(WPREMX) - 1.
         WRITE(6,'(/,A,1P,E12.4,/,A,1P,E12.4)')
     1 ' Maximum prebuckling displacement, WPREMX=',WPREMX,
     1 ' Displacement margin,              WPRMAR=',WPRMAR
C BEG DEC 2005
         NSTEP = KSTEP + 1
         FTIME(NSTEP) = TOME
         FDISP(NSTEP) = ABS(WPREMX)
         WRITE(6,'(/,A)') '   Maximum'
         WRITE(6,'(A)')   ' Displacement       time      time step'
         WRITE(6,'(A,I3)')'    WPREMX          TIME        KSTEP=',
     1   KSTEP
         DO 211 ISTEP = KMIN,NSTEP
            WRITE(6,'(1P,2E14.6)') FDISP(ISTEP),FTIME(ISTEP)
  211    CONTINUE
C BEG FEB 2008
         FDISP2(NSTEP) = ABS(ENDUV)
         WRITE(6,'(/,A)') '     End'
         WRITE(6,'(A)')   ' Displacement       time      time step'
         WRITE(6,'(A,I3)')'    ENDUV          TIME        KSTEP=',
     1   KSTEP
         DO 212 ISTEP = KMIN,NSTEP
            WRITE(6,'(1P,2E14.6)') FDISP2(ISTEP),FTIME(ISTEP)
  212    CONTINUE
C END FEB 2008
         WRITE(6,'(A,I3)')' End of displacement-time curve for KSTEP=',
     1   KSTEP
C END DEC 2005
C END AUG 2005
      IF (INDIC.EQ.0) GO TO 90
  110 CONTINUE
      IF (ISIG.EQ.1) KKKK = KKKK + 1
      IF (ISIG.EQ.1) CALL LOADS
C
C    SUBROUTINE ARRAYS-- THE STABILITY EQUATIONS ARE DERIVED IN ARRAYS
C                        THE VALUES OF C(I,J) FOUND IN PRE33 ARE USED
  115 CONTINUE
      CALL ARRAYS
      IF (ISIGNL.EQ.2) GO TO 130
C     CALL SR100T(2)
C
C     CALL OVERLAY(5HBMAIN,6,0)   (CDC VERSION)
C
      IF (INDIC.EQ.-2.AND.ISIG.EQ.0) GO TO 90
      IF (INDIC.NE.-2) GO TO 120
      IF (KSTEP.GE.KMAX) GO TO 130
      GO TO 110
  120 CONTINUE
      ISIG = 0
C
C    SUBROUTINE BUCKLE-- EIGENVALUES ARE CALCULATED IN BUCKLE.
C     CALL SR100T(2)
      AXB = 0.0
      CALL BUCKLE
      IF (INDIC.EQ.-2) GO TO 110
C     CALL SR100T(2)
C
C     CALL OVERLAY(5HBMAIN,7,0)   (CDC VERSION)
C
C
      NTRY = NTRY + 1
      N = N + INCRB
      IF (N.LE.NMAXB) GO TO 110
  130 CONTINUE
      IF (NTRY.LE.1) GO TO 160
      IB(1) = IDD
      IB(2) = ISER
      IB(3) = IDMAX
      IB(4) = ICUR
      IB(5) = ISTAT
      DO 140 I = 1,495
      IP = I + 5
  140 IB(IP) = IPMODE(I)
      DO 150 I = 1,50
      IP = I + 500
  150 IB(IP) = IVEC(I)
      DO 155 I = 1,100
      IP = I + 550
  155 B(IP) = TPAST(I)
c
      stofile = 9
      fname = casename(1:index(casename, ' ')-1)//'.BLK'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='OLD')
#if rs6k
        rewind(stofile)
#endif
      else
	OPEN(UNIT=stofile, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='NEW')
      endif
      CALL STORCM
      close(stofile)
c
  160 CONTINUE
      CALL GASP(DUM1,DUM2,-2,DUM3)
c Added 11/90 to clear IEEE FPE warnings
      call ieeexx
c End 11/90
      END
C=DECK      MAIN1
      SUBROUTINE MAIN1
C        ETAN(I,J)-TANGENT MODULI --ITH POINT ON STRESS-STRAIN CURVE
C                  OF JTH KIND OF SHELL MATERIAL
C    *   MAXTRL - MAXIMUM NUMBER OF TRIALS PERMITTED. MAKE LESS THAN 10
C        ITRIAL -  CURRENT NUMBER OF TRIAL. MUST BE LESS THAN OR EQUAL
C                  TO MAXTRL
C    *   EMAX(I) - MAXIMUM STRAIN FOR ITH KIND OF SHELL MATERIAL
C        ATWEEN(I)-CONTROL INTEGER WHICH TELLS PROGRAM WHETHER MATERIAL
C                  OF ITH SEGMENT IS ISOTROPIC, HAS STRENGTH ONLY IN
C                  MERIDIONAL DIRECTION, OR HAS STRENGTH ONLY IN
C                  CIRCUMFERENTIAL DIRECTION
C    *   SBRDF(I)- NO LONGER USED.
C    *   EPEFF(J,I)-EFFECTIVE STRAIN, JTH CALLOUT OF ITH MATERIAL (FOR
C                  SPECIFICATION OF STRESS-STRAIN CURVE OF ITH MAT'L
C    *   SGEFF(J,I)-EFFECTIVE STRESS--SEE EPEFF FOR REST OF DEFINITION
C    *   NITEG(I) -NUMBER OF INTEGRATION POINTS TO BE USED THROUGH
C                  THICKNESS IN ITH TYPE OF SHELL MATERIAL
C    *   EE(I)  -  ELASTIC MODULUS OF ITH SHELL MATERIAL
C    *   FNUE(I) - POISSON RATION OF ITH SHELL MATERIAL
C    *   AP(I)  -  THERMAL EXPANSION COEFFICIENT OF ITH SHELL MATERIAL
C    *   TFLOOR -  AMBIENT TEMPERATURE OF SHELL FOR CREEP DATA
C    *   CREEPN(I)-EXPONENT TO BE APPLIED TO TIME VARIABLE IN CREEP
C    *   CREEPM(I)-EXPONENT OF STRESS FOR ITH SHELL MATERIAL, CREEP
C    *   CREEPA(I)-CONSTANT TO BE USED IN NORTON CREEP LAW
C    *   CREEPB(I)-FACTOR TO BE USED TO ADJUST FOR PRIMARY CREEP.
C                  THIS FACTOR MUST BE EQUAL TO THE MODULUS IF NO AD-
C                  JUSTMENT IS TO BE MADE, MUST BE SMALLER THAN THE
C                  MODULUS OTHERWISE
C    *   PREROT -  NO LONGER USED
C        ERR    -  MAXIMUM ERROR PERMITTED IN SOL'N OF NONLINEAR STRESS
C    *   R1(I)  -  RADIAL DISTANCE FROM ATTACHMENT POINT TO BEGINNING
C                  OF ITH KIND OF DISCRETE RING SEGMENT
C    *   R2(I)  -  AXIAL DISTANCE ,  AS ABOVE FOR R1
C    *   PHI(I) -  ANGLE IN DEGRESS BETWEEN RADIUS AND ORIENTATION OF
C                  ITH DISCRETE RING SEGMENT
C    *   T(I)   -  THICKNESS OF ITH DISCRETE RING SEGMENT (CONSTANT)
C    *   FL(I)  -  LENGTH L OF ITH DISCRETE RING SEGMENT
C    *   E(I)   -  ELASTIC MODULUS OF ITH DISCRETE RING SEGMENT
C    *   ALPHA(I) -THERMAL EXPANSION COEFFICIENT OF ITH DISCRETE RING SE
C    *   TEMP(I) - TEMPERATURE CALLOUT FOR DISCRETE RING SEGMENT
C    *   EPS(I) -  EFFECTIVE
C    *   EPS(I) -  STRAIN CALLOUT FOR SPECIFICATION OF STRESS-STRAIN
C                  CURVE OF DISCRETE RING
C    *   SIGMA(I) -STRESS FOR SPECIFICATION OF STRESS-STRAIN CURVE
C                  OF DISCRETE RING
C        CMAX  -   MAXIMUM C11 IN ENTIRE SHELL
C        CLAST  -  I DON'T THINK ITS USED, BUT NOT SURE
C    *   V(I)   -  AXIAL LOAD APPLIED TO CENTROID OF ITH DISCRETE RING
C    *   HF(I)   - RADIAL LOAD APPLIED TO CENTROID OF ITH DISCRETE RING
C    *   FM(I)  -  MERIDIONAL MOMENT APPLIED AROUND CENTROID OF ITH RING
C    *   DTEMP(I) -TYPE OF TEMPERATURE VARIATION WITH TIME, ITH SEGMENT
C    *   STEP(I) - TYPE OF PRESSURE, SURFACE TRACTION TIME VARIATION
C    *   STEP1(I) -TYPE OF AXIAL LOAD TIME-VARIATION, ITH DISCRETE RING
C    *   STEP2(I) -TYPE OF RADIAL LOAD TIME-VARIATION, ITH DISCRETE RING
C    *   STEP3(I) -TYPE OF MERIDIONAL MOMENT TIME VARIATION,ITH RING
C        VSAVE(I)- SAME DEFINITION AS V, EXCEPT THIS IS A SAVED QUANTITY
C        HSAVE(I)- SAME DEFINITION AS HF,EXCEPT THIS IS A SAVED QUANTITY
C        FMSAVE(I)-SAME DEFINITION AS FM,EXCEPT THIS IS A SAVED QUANTITY
C        IPRW(I) - STORAGE LOCATION (ON DISK) OF ITH BLOCK OF PRESTRESS
C                  STIFFNESS MATRIX
C        LSTAT  -  KEEPS TRACK OF LOCATION IN ARRAY OF DISCRETE RING
C                  PLASTIC AND CREEP STRAINS
C        KRSEG  -  DISCRETE RING SEGMENT COUNTER
C        KRING  -  DISCRETE RING COUNTER
C        BET(I) =  MERIDIONAL ROTATION OF ITH DISCRETE RING, CURRENT
C                  TIME STEP
C        BETS(I) = MERIDIONAL ROTATION OF DISCRETE RING, LAST TIME STEP
C        WS(I)  -  RADIAL DISPLACEMENT OF ATTACHMENT POINT OF ITH
C                  DISCRETE RING, CURRENT TIME STEP
C        WSS(I) -  RADIAL DISPLACEMENT OF ATTACHMENT POINT OF ITH DIS-
C                  CRETE RING, LAST TIME STEP
C        IDD,ISER,ILAST,ICUR,ISTAT- CERTAIN DISK STORAGE DATA
C        TEMPS(I) -TEMPERATURE MULTIPLIER, LAST TIME STEP
C        IDRW(I,J)-DISK STORAGE LOCATIONS FOR STABILITY MATRICES, IN
C                  BLOCKS--- I = BLOCK NUMBER,  J = 1=STIFFNESS MATRIX
C                                               J = 2 = LOAD-GEOMETRIC
C                                               J= 5 = SHIFTED MATRIX
      COMMON/MATP2/ETAN(20,9),MAXTRL,ITRIAL,EMAX(9),ATWEEN(95),SBRDF(95)
      COMMON/MATPRO/EPEFF(20,9),SGEFF(20,9),NITEG(9),EE(9),FNUE(9),AP(9)
      COMMON/CDATA/TFLOOR,CREEPN(9),CREEPM(9),CREEPA(9),CREEPB(9)
      COMMON/PRERT/PREROT
      COMMON/ERROR/ERR
      COMMON/RPLST1 /R1(99),R2(99),PHI(99),T(99),FL(99),E(10),ALPHA(10)
      COMMON/RPLST2/TEMP(100),EPS(100),SIGMA(100)
      COMMON/CMAXS/CMAX
      COMMON/CLST/CLAST
      COMMON/FORCES/V(99),HF(99),FM(99)
      COMMON/STEPS/DTEMP(201),STEP(201),STEP1(99),STEP2(99),STEP3(99)
      COMMON/FOSAVE/VSAVE(99),HSAVE(99),FMSAVE(99)
      COMMON/IDENT/IPRW(20)
      COMMON/RLSTAT/LSTAT,KRSEG,KRING,BET(99),BETS(99),WS(99),WSS(99)
      COMMON/AUXSTO/IDD,ISER,ILAST,ICUR,ISTAT
      COMMON/RGFCES/RHF(99),RHFIX(99)
      COMMON/SVTEMP/TEMPS(201)
      COMMON/BCK/IDRW(20,5)
      COMMON/RCDATA/RCREEN(9),RCREEM(9),RCREEA(9),RCREEB(9)
      COMMON/IBUNCH/INOW,INOWH,INOWZ,MPROPX,NANR,NSME,NQ1,NQ2,NQ3,ICHNGE
      COMMON/ECFFI/ECEFF(100)
      COMMON/TEMTUR/TEMPP(201),P(201)
      COMMON/SVP/PS(201)
      COMMON/FUTIME/DTIMEF
      COMMON/RINDEX/JBEGIN,KBEGIN,LBEGIN,KSEGS
      COMMON/ORTA/IFLGG,KTM,KROOTS
      COMMON/MISCEL/ICOND1,ICOND2,KK,NSUB,KLAP,I5TOT,IC,III,IV
      COMMON/OUTP/NPRT
      COMMON/IDEFOM/INDEX
      COMMON/ORTHP/AL1(20),AL2(20),EXX(20),EYY(20),FNUXY(20),GS(20)
      RETURN
      END
C=DECK      LOADS
      SUBROUTINE LOADS
C
C     OVERLAY(2,0)           (CDC VERSION)
C     PROGRAM LOADS     (CDC VERSION)
C
C     APPLIED LOADS FOR NONLINEAR AXISYMMETRIC ANALYSIS ESTABLISHED FOR
C     NEXT LOAD STEP.
C
      COMMON/SEGS/NSEG,M2,I5(201),I2,I2G
      COMMON/FORCES/V(99),HF(99),FM(99)
      COMMON/FOSAVE/VSAVE(99),HSAVE(99),FMSAVE(99)
      COMMON/TLOADS/FTLOAD(100,2),NTIME(11),ITIME
      COMMON/STEPS/DTEMP(201),STEP(201),STEP1(99),STEP2(99),STEP3(99)
      COMMON/TEMTUR/TEMP(201),P(201)
      COMMON/TOMER/TOME,DTIME
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/SVTOM/TOMES
      COMMON/STRATG/IDETER,IDETFX
      COMMON/SVTEMP/TEMPS(201)
      COMMON/SVP/PS(201)
      COMMON/FLSTEP/KSTEP,KSTEPM
      COMMON/FUTIME/DTIMEF
      COMMON/KKSSP/KMIN,KMAX
      COMMON/SIGNALL/ISIG,KKKK,NSTEPS,LSTEPS(50),TIMES(51)
      COMMON/ECFFI/TPAST(100)
      IF (ISIG.EQ.0) GO TO 5
      KSTEP = LSTEPS(KKKK)
      TOME = TIMES(KKKK)
      TOMES = TIMES(1)
      IF (KSTEP.GT.1) TOMES = TPAST(KSTEP-1)
      IF (KKKK.LE.1) GO TO 3
      TOMES = TIMES(KKKK-1)
    3 CONTINUE
      DTIME = TOME - TOMES
      GO TO 33
    5 CONTINUE
      IF (KSTEPM.EQ.1) TOME = TPAST(KSTEP)
      KSTEP = KSTEP + 1
      IF (KSTEP.NE.KMIN.OR.ITIME.NE.2) GO TO 30
      ITIME = 0
      DO 10 I=1,11
   10 NTIME(I) = 0.0
      DO 20 I=1,100
      FTLOAD(I,1) = 0.0
   20 FTLOAD(I,2) = 0.0
C
C     TFUNCT GETS NEW TIME FUNCTIONS FOR LOADS IF WE WANT THEM
C
      CALL TFUNCT(FTLOAD,NTIME)
   30 CONTINUE
      TOMES = TOME
      ZERO = 0.0
C
C     THIS CALL TO TLOAD GETS TIME INCREMENT
C
      IF (ITIME.EQ.0) CALL TLOAD(ZERO,DTIME,TOMES,0)
      IF (KSTEP.GT.1) TOME = TOME + DTIME
      DTIMEF = DTIME
C
C     THIS CALL TO TLOAD GETS FUTURE TIME INCREMENT, WHICH IS NEEDED
C     FOR CREEP PROBLEMS
C
      IF(ITIME.EQ.0) CALL TLOAD(ZERO,DTIMEF,TOME,0)
   33 CONTINUE
      TPAST(KSTEP) = TOME
      IF (KSTEPM.EQ.1) GO TO 65
      WRITE(6,35)
   35 FORMAT(1H1)
      WRITE(6,36) KSTEP
   36 FORMAT(46H ***** CALCULATIONS BEGIN FOR TIME STEP NUMBER       I3,
     1 7H  *****  //)
   40 FORMAT(/48H ****************************************            /)
      WRITE(6,50) TOME , DTIME
   50 FORMAT(  7H TIME = 1PE17.8, 25H CURRENT TIME INCREMENT = 1PE17.8/)
      WRITE (6,60)
   60 FORMAT(' SEGMENT   PRESSURE MULTIPLIER   TEMPERATURE MULTIPLIER
     1(MULTIPLY THESE AMPLITUDES BY DISTRIBUTIONS  GIVEN FOR EACH SEGMEN
     1T)'/)
   65 CONTINUE
      DO 80 I=1,NSEG
C
C     GET TEMPERATURE MULTIPLIERS FOR LAST STEP...TEMPS(I)
C
      CALL TLOAD(DTEMP(I),FLOAD,TOMES,1)
      TEMPS(I) = FLOAD
      IF (KSTEP.EQ.1) TEMPS(I) = 0.0
C
C     GET PRESSURE MULTIPLIERS FOR LAST STEP..PS(I)
C
      CALL TLOAD(STEP(I),FLOAD,TOMES,1)
      PS(I) = FLOAD
      IF (KSTEP.EQ.1) PS(I) = 0.0
C
C     GET PRESSURE MULTIPLIER FOR CURRENT STEP... P(I)
C
      CALL TLOAD(STEP(I),FLOAD,TOME,1)
      P(I) = FLOAD
C
C     GET TEMPERATURE MULTPLIERS FOR CURRENT STEP..TEMP(I)
C
      CALL TLOAD(DTEMP(I),FLOAD,TOME,1)
      TEMP(I) = FLOAD
      IF (KSTEPM.EQ.0) WRITE(6,70) I, P(I),TEMP(I)
   70 FORMAT(I5,1P2E24.8)
   80 CONTINUE
      IF (KSTEPM.EQ.0) WRITE(6,85)
   85 FORMAT(1H0)
      IF (NTOT.EQ.0) GO TO 110
      DO 100 I=1,NTOT
C
C     GET AXIAL LINE LOADS V(I) FOR CURRENT STEP
C
      CALL TLOAD(STEP1(I), FLOAD, TOME,1)
      V(I) = VSAVE(I)*FLOAD
C
C     GET RADIAL LINE LOADS HF(I) FOR CURRENT STEP
C
      CALL TLOAD(STEP2(I), FLOAD, TOME,1)
      HF(I) = HSAVE(I)*FLOAD
C
C     GET LINE MOMENTS FM(I) FOR CURRENT STEP
C
      CALL TLOAD(STEP3(I), FLOAD, TOME,1)
      FM(I) = FMSAVE(I)*FLOAD
      IF (KSTEPM.EQ.0) WRITE(6,90) I,V(I),HF(I),FM(I)
   90 FORMAT(9H RING NO. I3,21H, AXIAL LOAD/LENGTH = E15.8,
     1 22H, RADIAL LOAD/LENGTH = E15.8, 17H, MOMENT/LENGTH = E15.8    )
  100 CONTINUE
  110 CONTINUE
      RETURN
C     RETURN CARD NOT NEEDED IN CDC VERSION
      END
C=DECK      SOLVE
      SUBROUTINE SOLVE(A,X,NBLK,IBLK,KEQ,FOC,DIAG,NT,NV)
C
      DOUBLE PRECISION A,X,AII
      DIMENSION A(*),X(NT,NV),IBLK(*),KEQ(*),FOC(*),DIAG(*)
C
C                  *****************************************
C                            FORWARD SWEEP
C                  *****************************************
      I1=1
      I=1
   10 I2=KEQ(I)
      NW = 2.*FOC(I2)
      IF (NBLK.GT.1) CALL GASP(A,NW,3,IBLK(I))
      J1=1
   20 II=I1
   30 J2 = FOC(II) - 1.
      LOCII = FOC(II)
      JL = II - LOCII
      AII=1./A(J2+1)
      DO 50 KK=1,NV
      IF (J2.LT.J1) GO TO 50
      DO 40 J=J1,J2
   40 X(II,KK)=X(II,KK)-A(J)*X(J+JL,KK)
   50 X(II,KK)=X(II,KK)*AII
      IF (II.EQ.I2) GO TO 60
      J1 = FOC(II) + 1.
      II=II+1
      GO TO 30
   60 IF (I.EQ.NBLK) GO TO 70
      I=I+1
      I1=I2+1
      GO TO 10
C                  *****************************************
C                            BACK SWEEP
C                  *****************************************
   70 II=I2
   80 J2 = FOC(II) - 1.
      AII = 1./DABS(A(J2+1))
      DO 100 KK=1,NV
      X(II,KK)=X(II,KK)*AII
      IF (J2.LT.J1) GO TO 100
      LOCII = FOC(II)
      JL = II - LOCII
      DO 90 J=J1,J2
   90 X(J+JL,KK)=X(J+JL,KK)-X(II,KK)*A(J)*SIGN(1.,DIAG(J+JL))
  100 CONTINUE
      II=II-1
      IF (II-I1) 130,110,120
  110 J1=1
      GO TO 80
  120 J1 = FOC(II-1) + 1.
      GO TO 80
  130 I=I-1
      IF (I-1) 170,140,150
  140 I1=1
      GO TO 160
  150 I1=KEQ(I-1)+1
  160 I2=KEQ(I)
      J1 = FOC(I2-1) + 1.
      NW = 2.*FOC(I2)
      IF (NBLK.GT.1) CALL GASP(A,NW,3,IBLK(I))
      GO TO 70
  170 RETURN
      END
C=DECK      FACTOR
      SUBROUTINE FACTOR(A,B,IBLK,DET,NEX,NBLK,KEQ,KBAND,FOC,DIAG,DI,KMAX
     1  )
      DOUBLE PRECISION A,B,DI,SUM
      DIMENSION A(*),B(*),IBLK(NBLK),KEQ(NBLK),KBAND(NBLK),FOC(*)
      DIMENSION DIAG(*)
      DIMENSION DI(*),KMAX(NBLK)
      COMMON/ORTA/IFLGG,KTM,KROOTS
      COMMON/OUTP/NPRT
      COMMON /INSTAB/ INDIC
C
C     KEQ(N)       TRUE EQUATION NUMBER OF LAST EQ IN BLOCK N
C     KBAND(N)     LOWEST TRUE UNKNOWN NUMBER REFERENCED IN BLOCK N
C     FOC(I)       RELATIVE LOCATION OF MAIN DIAGONAL OF EQ I IN BLOCK
C     IBLK(I)      AUXILIARY STORAGE INDEX NR FOR BLOCK I
C     NBLK         NUMBER OF BLOCKS
C     A            ARRAY WORKING SPACE (LARGEST BLOCK)
C     B            ARRAY WORKING SPACE (LARGEST BLOCK)
C     DIAG         ARRAY FOR MAIN DIAG OF MATRIX (SINGLE PRECISION)
      N=KEQ(NBLK)
      KTM=0
      I=1
      MB=0
C                                      NEXT I BLOCK
   10 J=I
      IA=1
      IF (I.EQ.1) GO TO 20
      IA=KEQ(I-1)+1
   20 CONTINUE
      IB=KEQ(I)
C                                      NEXT J BLOCK
   30 JB=KEQ(J)
      JA=1
      IF (J.EQ.1) GO TO 40
      JA=KEQ(J-1)+1
   40 CONTINUE
      IF (MB.EQ.J) GO TO 60
      IF (MB.EQ.0) GO TO 50
      IF (NBLK.GT.1) CALL GASP(B,NW,1,IBLK(MB  ))
   50 N1=KEQ(J)
      NW = FOC(N1)*2.
      IF (NBLK.GT.1) CALL GASP(B,NW,3,IBLK(J   ))
      MB=J
   60 IG=1
C                                      LOOP ON I BLOCK
   70 DO 230 II=IA,IB
      I1=0
      I2 = FOC(II)
      IF (II.EQ.IA) GO TO 80
      I1 = FOC(II-1)
   80 IN=I2-I1
C                                      LOOP ON J BLOCK
   90 J2 = 0
      JM = JA
      IF (JA.GE.II) GO TO 100
      JM = II
      J2 = I1
  100 CONTINUE
      JE = MIN0(JB, II+KMAX(J))
      IF (JE.LT.JM) GO TO 230
      DO 220 JJ=JM,JE
      IDIF = JJ - II
      LOCJJ = FOC(JJ)
      JN = LOCJJ - J2 - IDIF
      J2 = LOCJJ
      IF (JN.LE.0) GO TO 220
      KN=MIN0(IN,JN)-1
      IF (KN) 220,170,110
  110 KA=I2-KN-1
      KB=J2-KN-1-IDIF
      SUM=0.
      IF (IDIF.GT.0) GO TO 150
      KL=II-I2
      I11=I1+1
      I21=I2-1
      DO 140 K=I11,I21
      IF (DIAG(K+KL)) 120,130,130
  120 A(K)=-B(K)
      GO TO 140
  130 A(K)=B(K)
  140 CONTINUE
  150 DO 160 K=1,KN
  160 SUM=SUM+A(K+KA)*B(K+KB)
      B(J2-IDIF)=B(J2-IDIF)-SUM
  170 IF (I.NE.J) GO TO 210
      IF (IDIF.GT.0) GO TO 210
      DI(IG) = DSQRT(DABS(B(I2)))
      B(I2) = DSIGN(DI(IG),B(I2))
      IF (B(I2)) 190,180,200
  180 B(I2)=1.
      DI(IG)=1.
      GO TO 200
  190 KTM=KTM+1
  200 DIAG(II)=B(I2)
      GO TO 220
  210 B(J2-IDIF)=B(J2-IDIF)/DI(IG)
  220 CONTINUE
  230 IG=IG+1
  240 J=J+1
      IF (J.GT.NBLK) GO TO 250
      IF (IB.GE.KBAND(J)) GO TO 30
      GO TO 240
  250 I=I+1
      IF (I.LE.NBLK) GO TO 10
C                                      COMPUTE DETERMINANT
      IF (NBLK.GT.1) CALL GASP(B,NW,1,IBLK(NBLK))
      DET=1.
      NEX=0
      DO 280 I=1,N
      DET=DET*DIAG(I)
      IF (DET.EQ.0.) GO TO 280
  260 IF (ABS(DET).LT.1.E+10) GO TO 270
      DET=DET*1.E-10
      NEX=NEX+10
      GO TO 260
  270 IF (ABS(DET).GT.1.E-10) GO TO 280
      DET=DET*1.E+10
      NEX=NEX-10
      GO TO 270
  280 CONTINUE
      IF (NPRT.GT.2) WRITE (6,290)DET,NEX,(DIAG(I),I=1,N)
  290 FORMAT(6H  DET=E17.7,7H,  NEX= I6,16H,   DIAG FOLLOWS  /
     1  (10E12.4))
      RETURN
      END
C=DECK      FACTR
      SUBROUTINE FACTR(A,B,IBLK,DET,NEX,NBLK,KEQ,KBAND,FOC,DIAG,DI,KMAX)
      DOUBLE PRECISION A,B,DI,SUM
      DIMENSION A(*),B(*),IBLK(NBLK),KEQ(NBLK),KBAND(NBLK),FOC(*)
      DIMENSION DIAG(*)
      DIMENSION DI(*),KMAX(NBLK)
      COMMON/ORTA/IFLGG,KTM,KROOTS
      COMMON/OUTP/NPRT
      COMMON /INSTAB/ INDIC
C
C
C     KEQ(N)       TRUE EQUATION NUMBER OF LAST EQ IN BLOCK N
C     KBAND(N)     LOWEST TRUE UNKNOWN NUMBER REFERENCED IN BLOCK N
C     FOC(I)       RELATIVE LOCATION OF MAIN DIAGONAL OF EQ I IN BLOCK
C     IBLK(I)      AUXILIARY STORAGE INDEX NR FOR BLOCK I
C     NBLK         NUMBER OF BLOCKS
C     A            ARRAY WORKING SPACE (LARGEST BLOCK)
C     B            ARRAY WORKING SPACE (LARGEST BLOCK)
C     DIAG         ARRAY FOR MAIN DIAG OF MATRIX (SINGLE PRECISION)
      N=KEQ(NBLK)
      KTM=0
      I=1
      MB=0
C                                      NEXT I BLOCK
   10 J=I
      IA=1
      IF (I.EQ.1) GO TO 20
      IA=KEQ(I-1)+1
   20 CONTINUE
      IB=KEQ(I)
C                                      NEXT J BLOCK
   30 JB=KEQ(J)
      JA=1
      IF (J.EQ.1) GO TO 40
      JA=KEQ(J-1)+1
   40 CONTINUE
      IF (MB.EQ.J) GO TO 60
      IF (MB.EQ.0) GO TO 50
      IF (NBLK.GT.1) CALL GASP(B,NW,1,IBLK(MB  ))
   50 N1=KEQ(J)
      NW = FOC(N1)*2.
      IF (NBLK.GT.1) CALL GASP(B,NW,3,IBLK(J   ))
      MB=J
   60 IG=1
C                                      LOOP ON I BLOCK
   70 DO 230 II=IA,IB
      I1=0
      I2 = FOC(II)
      IF (II.EQ.IA) GO TO 80
      I1 = FOC(II-1)
   80 IN=I2-I1
C                                      LOOP ON J BLOCK
   90 J2 = 0
      JM = JA
      IF (JA.GE.II) GO TO 100
      JM = II
      J2 = I1
  100 CONTINUE
      JE = MIN0(JB, II+KMAX(J))
      IF (JE.LT.JM) GO TO 230
      DO 220 JJ=JM,JE
      IDIF = JJ - II
      LOCJJ = FOC(JJ)
      JN = LOCJJ - J2 - IDIF
      J2 = LOCJJ
      IF (JN.LE.0) GO TO 220
      KN=MIN0(IN,JN)-1
      IF (KN) 220,170,110
  110 KA=I2-KN-1
      KB=J2-KN-1-IDIF
      SUM=0.
      IF (IDIF.GT.0) GO TO 150
      KL=II-I2
      I11=I1+1
      I21=I2-1
      DO 140 K=I11,I21
      IF (DIAG(K+KL)) 120,130,130
  120 A(K)=-B(K)
      GO TO 140
  130 A(K)=B(K)
  140 CONTINUE
  150 DO 160 K=1,KN
  160 SUM=SUM+A(K+KA)*B(K+KB)
      B(J2-IDIF)=B(J2-IDIF)-SUM
  170 IF (I.NE.J) GO TO 210
      IF (IDIF.GT.0) GO TO 210
      DI(IG) = DSQRT(DABS(B(I2)))
      B(I2) = DSIGN(DI(IG),B(I2))
      IF (B(I2)) 190,180,200
  180 B(I2)=1.
      DI(IG)=1.
      GO TO 200
  190 KTM=KTM+1
  200 DIAG(II)=B(I2)
      GO TO 220
  210 B(J2-IDIF)=B(J2-IDIF)/DI(IG)
  220 CONTINUE
  230 IG=IG+1
  240 J=J+1
      IF (J.GT.NBLK) GO TO 250
      IF (IB.GE.KBAND(J)) GO TO 30
      GO TO 240
  250 I=I+1
      IF (I.LE.NBLK) GO TO 10
C                                      COMPUTE DETERMINANT
      IF (NBLK.GT.1) CALL GASP(B,NW,1,IBLK(NBLK))
      DET=1.
      NEX=0
      DO 280 I=1,N
      DET=DET*DIAG(I)
      IF (DET.EQ.0.) GO TO 280
  260 IF (ABS(DET).LT.1.E+10) GO TO 270
      DET=DET*1.E-10
      NEX=NEX+10
      GO TO 260
  270 IF (ABS(DET).GT.1.E-10) GO TO 280
      DET=DET*1.E+10
      NEX=NEX-10
      GO TO 270
  280 CONTINUE
      IF (NPRT.GT.2) WRITE (6,290)DET,NEX,(DIAG(I),I=1,N)
  290 FORMAT(6H  DET=E17.7,7H,  NEX= I6,16H,   DIAG FOLLOWS  /
     1  (10E12.4))
      RETURN
      END
C=DECK      FUNCT
      FUNCTION FUNCT(ZETA)
C     VARIABLES, FUNCT GIVES THE TEMPERATURE DISTRIBUTION THRU THE
C     THICKNESS OF THE SHELL WALL.
C
      COMMON/ZGRAD/NTSGD
      COMMON/TTTHK/TP(10),ZP(10),NTHICK,ZRF
      FUNCT = TP(1)
      IF (NTHICK.EQ.1) GO TO 30
      J = 1
      ZZ = ZRF + ZETA
      DO 10 I=2,NTHICK
      J = J + 1
      IF (ZZ.LT.ZP(I)) GO TO 20
   10 CONTINUE
   20 J1 = J - 1
      FUNCT = TP(J1)
      ZDIF = ZP(J) - ZP(J1)
      IF (ZDIF) 25,30,25
   25 CONTINUE
      FUNCT = (TP(J)-TP(J1))*(ZZ-ZP(J1))/(ZP(J)-ZP(J1))     + TP(J1)
   30 IF (NTSGD.EQ.0) RETURN
      FUNCT = FUNCT*ZETA
      RETURN
      END
C=DECK      MATMU4
      SUBROUTINE MATMU4(B,A,C,K,J,IZERO)
C
C     CALLED FROM BOTH PRESTS AND STABIL (LINKS 2 AND 3). SIMILAR TO
C     MATMU2 EXCEPT FOR ONE STATEMENT  AFTER LABEL 50.
C     WE FORM THE PRODUCT C = A(TRANSPOSE)XBXA, WHERE B IS SYMMETRIC
C
      DOUBLE PRECISION B,A,C,D
      DIMENSION B(K,K),A(K,J),C(J,J),D(7,7)
      DO 10 KK=1,K
      DO 10 JJ=1,J
      D(KK,JJ) = 0.0
   10 CONTINUE
      DO 30 KK=1,K
      DO 30 JJ=1,J
      DO 20 LL=1,K
      D(KK,JJ) = D(KK,JJ) + B(KK,LL)*A(LL,JJ)
   20 CONTINUE
   30 CONTINUE
      IF (IZERO.EQ.1) GO TO 50
      DO 40 II=1,J
      DO 40 JJ=1,J
      C(II,JJ) = 0.0
   40 CONTINUE
   50 DO 70 II=1,J
      DO 70 JJ=1,II
      DO 60 KK=1,K
      C(II,JJ) = C(II,JJ) + A(KK,II)*D(KK,JJ)
   60 CONTINUE
   70 CONTINUE
      RETURN
      END
C=DECK      TFUNCT
      SUBROUTINE TFUNCT(FTLOAD,NTIME)
      DIMENSION FTLOAD(100,2),NTIME(11)
C     HOW LOADS VARY DURING CASE
C
C     NTIME(1) = NUMBER OF CALLOUTS FOR TIME INCREMENT
C     FTLOAD(I,1) I=1,NTIME(1) = THE VALUES OF THE TIME INCREMENTS
C     FTLOAD(I,2) I=1,NTIME(1) = THE TIMES CORRESPONDING TO THE VALUES
C                                OF DTIME. DTIME VARIES LINEARLY FOR
C                                TIMES BETWEEN CALLOUTS.
C     NFTIME = NUMBER OF DIFFERENT FUNCTIONS OF TIME (LOADS)
C     NTIME(J),J=2,NFTIME+1  QUANTITIES OF CALLOUTS FOR LOAD-FUNCTIONS
C                            OF TIME.
C     FTLOAD(J,1),J=NPOS,NPEND = F(T)  (LOAD-FUNCTION OF TIME)
C     FTLOAD(J,2),J=NPOS,NPEND = T     TIME CORRESPONDING TO LOAD-CALLOU
C
   10 FORMAT(10I6)
   20 FORMAT(6E12.8)
      READ (5,10)NTIME(1)
      NT1 = NTIME(1)
      READ (5,20)(FTLOAD(I,1),I=1,NT1)
      READ (5,20)(FTLOAD(I,2),I=1,NT1)
      READ (5,10)NFTIME
      ITIME = NFTIME
      NF1 = NFTIME + 1
      READ (5,10)(NTIME(J),J=2,NF1)
      NPOS = 1
      DO 30 I=1,NFTIME
      I1 = I + 1
      NPOS = NPOS + NTIME(I)
      NPEND = NPOS + NTIME(I1) - 1
      READ (5,20)(FTLOAD(J,1),J=NPOS,NPEND)
      READ (5,20)(FTLOAD(J,2),J=NPOS,NPEND)
   30 CONTINUE
      WRITE (6,40)
   40 FORMAT(//46H  TIME STEPS AND LOADS AS FUNCTIONS OF TIME.     )
      WRITE (6,50)
   50 FORMAT(//43H  TIME STEPS(HOURS) AS FUNCTION OF TIME           //)
      NT1 = NTIME(1)
      DO 70 I=1,NT1
      WRITE (6,60)FTLOAD(I,2),FTLOAD(I,1)
   60 FORMAT(9H  TIME = 1PE12.4, 20H HOURS. TIME STEP =  1PE12.4,
     1 8H HOURS.  )
   70 CONTINUE
      WRITE (6,80)
   80 FORMAT(//93H  NOTE.... MAGNITUDE OF TIME STEP DETERMINED BY LINEAR
     1 INTERPOLATION BETWEEN TIME-CALLOUTS         /10X,95H TIME STEP CO
     2RRESPONDS TO THE INTERVAL IMMEDIATELY FOLLOWING THE CORRESPONDING
     3TIME-CALLOUT.                             )
      WRITE (6,90)ITIME
   90 FORMAT(// I3,47H DIFFERENT FUNCTIONS OF TIME USED FOR LOADING.
     1       /4X,105H ACTUAL LOADS ARE GIVEN BY THESE FUNCTIONS MULTIPLI
     2ED BY AMPLITUDE MULTIPLIED BY SPACIAL DISTRIBUTION              /)
      NPOS = 1
      DO 130 I=1,ITIME
      I1 = I + 1
      NPOS = NPOS + NTIME(I)
      NPEND = NPOS + NTIME(I1) - 1
      WRITE (6,100)I
  100 FORMAT(///29H  LOADING TIME FUNCTION TYPE     I3,10H FOLLOWS   //)
      DO 120 J=NPOS,NPEND
      WRITE (6,110)FTLOAD(J,2),FTLOAD(J,1)
  110 FORMAT(9H  TIME = 1PE12.4,15H HOURS. LOAD =   1PE12.4)
  120 CONTINUE
  130 CONTINUE
      RETURN
      END
C=DECK      TLOAD
      SUBROUTINE TLOAD(STEP,FLOAD,TOME,INDEX)
C
C     THIS SUBROUTINE CALCULATES FLOAD, GIVEN STEP AND TOME
C
C     STEP = INDEX FOR CHOOSING TYPE OF TIME DEPENDENCE OF LOAD
C     TOME = ELAPSED TIME SINCE BEGINNING OF CASE
C     FLOAD = VALUE OF THE PARTICULAR FUNCTION OF TIME WHICH THIS
C             PARTICULAR LOAD ASSUMES AT TIME T = TOME (ACTUALLY,
C             THE LOAD IS GIVEN BY AN AMPLITUDE FACTOR TIMES FLOAD.
C
C
      COMMON/TLOADS/FTLOAD(100,2),NTIME(11),ITIME
      FLOAD = 0.0
      ITYPE = STEP
      IF (INDEX.EQ.0) GO TO 10
      IF (ITYPE.GT.10.OR.ITYPE.EQ.0) GO TO 60
   10 I1 = ITYPE + 1
      N1 = NTIME(I1)
      NPOS = 0
      IF (ITYPE.EQ.0) GO TO 30
      DO 20 I=1,ITYPE
   20 NPOS = NPOS + NTIME(I)
   30 DO 40 I=2,N1
      NPOS1 = NPOS + I
      T2 = FTLOAD(NPOS1,2)
      IF (TOME.LT.T2) GO TO 50
   40 CONTINUE
   50 NPOSM = NPOS1 - 1
      T1 = FTLOAD(NPOSM,2)
      F1 = FTLOAD(NPOSM,1)
      F2 = FTLOAD(NPOS1,1)
      T21 = T2-T1
      FLOAD = F1
      IF (T21) 55,60,55
   55 CONTINUE
      FLOAD = (F2- F1)*(TOME - T1)/(T2- T1) + F1
   60 CONTINUE
      RETURN
      END
C=DECK      LISTPL
      SUBROUTINE LISTPL(NSEG,I5)
C
C     PURPOSE IS TO LIST MAXIMUM PLASTIC STRAIN COMPONENTS AT 
C     MERIDIONAL STATIONS WHERE PLASTIC FLOW OCCURS...
C
      DIMENSION I5(201)
      COMMON/ITOTLL/ITOTLT,PLPNT(2000,2),E1MAX,E2MAX
C BEG AUG 2005
      COMMON/EPSEFX/EPSMAX(201,100,1),EPSMXX(201)
      COMMON/ORTHP2/SMM(20),EPSALL(20)
C END AUG 2005
C
      IF (E1MAX.LT.0.00001.AND.E2MAX.LT.0.00001) RETURN
C
      WRITE(6,10)
C BEG AUG 2005
   10 FORMAT(/' PLASTIC STRAINING OCCURS AT THE FOLLOWING STATIONS...'/
     1/'  SHELL     MERIDIONAL    MERIDIONAL   CIRCUMFERENTIAL',
     1 '    EFFECTIVE         UNIAXIAL'/
     1 ' SEGMENT     STATION     MAX. PLASTIC   MAX. PLASTIC',
     1 '      UNIAXIAL          STRAIN'/
     1 '                          STRAIN(%)      STRAIN(%)',
     1 '        STRAIN(%)         MARGIN'/)
C END AUG 2005
C
      ITOTL = 0
      DO 100 J = 1,NSEG
      I5J = I5(J)
      DO 90  I = 1,I5J
C
      ITOTL = ITOTL + 1
      AP1 = ABS(PLPNT(ITOTL,1))
      AP2 = ABS(PLPNT(ITOTL,2))
      IF (AP1.LT.0.00001.AND.AP2.LT.0.00001) GO TO 90
      PPL1 = 100.*PLPNT(ITOTL,1)
      PPL2 = 100.*PLPNT(ITOTL,2)
C BEG AUG 2005
      EPSMAR = 10.E+16
      IF (EPSMAX(J,I,1).GT.0.0)
     1 EPSMAR = EPSALL(1)/EPSMAX(J,I,1) - 1.0
      WRITE(6,20) J, I, PPL1,PPL2,EPSMAX(J,I,1),EPSMAR
   20 FORMAT(I5,I13,1PE17.4,1PE15.4,1PE17.4,1PE17.4)
C END AUG 2005
C
   90 CONTINUE
  100 CONTINUE
C
      PE1 = 100.*E1MAX
      PE2 = 100.*E2MAX
      WRITE(6,300) PE1,PE2
  300 FORMAT(/' ABSOLUTE VALUES OF THE MAXIMUM PLASTIC STRAINS IN % ='// 
     1' MERIDIONAL COMPONENT =',1PE12.4,',  CIRC. COMPONENT =',1PE12.4)
C
      RETURN
      END
