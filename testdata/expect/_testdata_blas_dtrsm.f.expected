COMMENT	> \brief \b DTRSM
COMMENT	*
COMMENT	*  =========== DOCUMENTATION ===========
COMMENT	*
COMMENT	* Online html documentation available at
COMMENT	*            http://www.netlib.org/lapack/explore-html/
COMMENT	*
COMMENT	*  Definition:
COMMENT	*  ===========
COMMENT	*
COMMENT	*       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
COMMENT	*
COMMENT	*       .. Scalar Arguments ..
COMMENT	*       DOUBLE PRECISION ALPHA
COMMENT	*       INTEGER LDA,LDB,M,N
COMMENT	*       CHARACTER DIAG,SIDE,TRANSA,UPLO
COMMENT	*       ..
COMMENT	*       .. Array Arguments ..
COMMENT	*       DOUBLE PRECISION A(LDA,*),B(LDB,*)
COMMENT	*       ..
COMMENT	*
COMMENT	*
COMMENT	*> \par Purpose:
COMMENT	*  =============
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*> DTRSM  solves one of the matrix equations
COMMENT	*>
COMMENT	*>    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
COMMENT	*>
COMMENT	*> where alpha is a scalar, X and B are m by n matrices, A is a unit, or
COMMENT	*> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
COMMENT	*>
COMMENT	*>    op( A ) = A   or   op( A ) = A**T.
COMMENT	*>
COMMENT	*> The matrix X is overwritten on B.
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Arguments:
COMMENT	*  ==========
COMMENT	*
COMMENT	*> \param[in] SIDE
COMMENT	*> \verbatim
COMMENT	*>          SIDE is CHARACTER*1
COMMENT	*>           On entry, SIDE specifies whether op( A ) appears on the left
COMMENT	*>           or right of X as follows:
COMMENT	*>
COMMENT	*>              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
COMMENT	*>
COMMENT	*>              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] UPLO
COMMENT	*> \verbatim
COMMENT	*>          UPLO is CHARACTER*1
COMMENT	*>           On entry, UPLO specifies whether the matrix A is an upper or
COMMENT	*>           lower triangular matrix as follows:
COMMENT	*>
COMMENT	*>              UPLO = 'U' or 'u'   A is an upper triangular matrix.
COMMENT	*>
COMMENT	*>              UPLO = 'L' or 'l'   A is a lower triangular matrix.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] TRANSA
COMMENT	*> \verbatim
COMMENT	*>          TRANSA is CHARACTER*1
COMMENT	*>           On entry, TRANSA specifies the form of op( A ) to be used in
COMMENT	*>           the matrix multiplication as follows:
COMMENT	*>
COMMENT	*>              TRANSA = 'N' or 'n'   op( A ) = A.
COMMENT	*>
COMMENT	*>              TRANSA = 'T' or 't'   op( A ) = A**T.
COMMENT	*>
COMMENT	*>              TRANSA = 'C' or 'c'   op( A ) = A**T.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] DIAG
COMMENT	*> \verbatim
COMMENT	*>          DIAG is CHARACTER*1
COMMENT	*>           On entry, DIAG specifies whether or not A is unit triangular
COMMENT	*>           as follows:
COMMENT	*>
COMMENT	*>              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
COMMENT	*>
COMMENT	*>              DIAG = 'N' or 'n'   A is not assumed to be unit
COMMENT	*>                                  triangular.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] M
COMMENT	*> \verbatim
COMMENT	*>          M is INTEGER
COMMENT	*>           On entry, M specifies the number of rows of B. M must be at
COMMENT	*>           least zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] N
COMMENT	*> \verbatim
COMMENT	*>          N is INTEGER
COMMENT	*>           On entry, N specifies the number of columns of B.  N must be
COMMENT	*>           at least zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] ALPHA
COMMENT	*> \verbatim
COMMENT	*>          ALPHA is DOUBLE PRECISION.
COMMENT	*>           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
COMMENT	*>           zero then  A is not referenced and  B need not be set before
COMMENT	*>           entry.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] A
COMMENT	*> \verbatim
COMMENT	*>          A is DOUBLE PRECISION array, dimension ( LDA, k ),
COMMENT	*>           where k is m when SIDE = 'L' or 'l'
COMMENT	*>             and k is n when SIDE = 'R' or 'r'.
COMMENT	*>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
COMMENT	*>           upper triangular part of the array  A must contain the upper
COMMENT	*>           triangular matrix  and the strictly lower triangular part of
COMMENT	*>           A is not referenced.
COMMENT	*>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
COMMENT	*>           lower triangular part of the array  A must contain the lower
COMMENT	*>           triangular matrix  and the strictly upper triangular part of
COMMENT	*>           A is not referenced.
COMMENT	*>           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
COMMENT	*>           A  are not referenced either,  but are assumed to be  unity.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] LDA
COMMENT	*> \verbatim
COMMENT	*>          LDA is INTEGER
COMMENT	*>           On entry, LDA specifies the first dimension of A as declared
COMMENT	*>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
COMMENT	*>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
COMMENT	*>           then LDA must be at least max( 1, n ).
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in,out] B
COMMENT	*> \verbatim
COMMENT	*>          B is DOUBLE PRECISION array, dimension ( LDB, N )
COMMENT	*>           Before entry,  the leading  m by n part of the array  B must
COMMENT	*>           contain  the  right-hand  side  matrix  B,  and  on exit  is
COMMENT	*>           overwritten by the solution matrix  X.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] LDB
COMMENT	*> \verbatim
COMMENT	*>          LDB is INTEGER
COMMENT	*>           On entry, LDB specifies the first dimension of B as declared
COMMENT	*>           in  the  calling  (sub)  program.   LDB  must  be  at  least
COMMENT	*>           max( 1, m ).
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Authors:
COMMENT	*  ========
COMMENT	*
COMMENT	*> \author Univ. of Tennessee
COMMENT	*> \author Univ. of California Berkeley
COMMENT	*> \author Univ. of Colorado Denver
COMMENT	*> \author NAG Ltd.
COMMENT	*
COMMENT	*> \date December 2016
COMMENT	*
COMMENT	*> \ingroup double_blas_level3
COMMENT	*
COMMENT	*> \par Further Details:
COMMENT	*  =====================
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*>  Level 3 Blas routine.
COMMENT	*>
COMMENT	*>
COMMENT	*>  -- Written on 8-February-1989.
COMMENT	*>     Jack Dongarra, Argonne National Laboratory.
COMMENT	*>     Iain Duff, AERE Harwell.
COMMENT	*>     Jeremy Du Croz, Numerical Algorithms Group Ltd.
COMMENT	*>     Sven Hammarling, Numerical Algorithms Group Ltd.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*  =====================================================================
IDENT	SUBROUTINE
IDENT	DTRSM
(	(
IDENT	SIDE
,	,
IDENT	UPLO
,	,
IDENT	TRANSA
,	,
IDENT	DIAG
,	,
IDENT	M
,	,
IDENT	N
,	,
IDENT	ALPHA
,	,
IDENT	A
,	,
IDENT	LDA
,	,
IDENT	B
,	,
IDENT	LDB
)	)
COMMENT	*
COMMENT	*  -- Reference BLAS level3 routine (version 3.7.0) --
COMMENT	*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
COMMENT	*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
COMMENT	*     December 2016
COMMENT	*
COMMENT	*     .. Scalar Arguments ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	ALPHA
IDENT	INTEGER
IDENT	LDA
,	,
IDENT	LDB
,	,
IDENT	M
,	,
IDENT	N
IDENT	CHARACTER
IDENT	DIAG
,	,
IDENT	SIDE
,	,
IDENT	TRANSA
,	,
IDENT	UPLO
COMMENT	*     ..
COMMENT	*     .. Array Arguments ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	A
(	(
IDENT	LDA
,	,
*	*)
,	,
IDENT	B
(	(
IDENT	LDB
,	,
*	*)
COMMENT	*     ..
COMMENT	*
COMMENT	*  =====================================================================
COMMENT	*
COMMENT	*     .. External Functions ..
IDENT	LOGICAL
IDENT	LSAME
IDENT	EXTERNAL
IDENT	LSAME
COMMENT	*     ..
COMMENT	*     .. External Subroutines ..
IDENT	EXTERNAL
IDENT	XERBLA
COMMENT	*     ..
COMMENT	*     .. Intrinsic Functions ..
IDENT	INTRINSIC
IDENT	MAX
COMMENT	*     ..
COMMENT	*     .. Local Scalars ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	TEMP
IDENT	INTEGER
IDENT	I
,	,
IDENT	INFO
,	,
IDENT	J
,	,
IDENT	K
,	,
IDENT	NROWA
IDENT	LOGICAL
IDENT	LSIDE
,	,
IDENT	NOUNIT
,	,
IDENT	UPPER
COMMENT	*     ..
COMMENT	*     .. Parameters ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	ONE
,	,
IDENT	ZERO
IDENT	PARAMETER
(	(
IDENT	ONE
=	=
IDENT	1
.	.
IDENT	0
IDENT	D
+	+
IDENT	0
,	,
IDENT	ZERO
=	=
IDENT	0
.	.
IDENT	0
IDENT	D
+	+
IDENT	0
)	)
COMMENT	*     ..
COMMENT	*
COMMENT	*     Test the input parameters.
COMMENT	*
IDENT	LSIDE
=	=
IDENT	LSAME
(	(
IDENT	SIDE
,	,
STRING	'L'
)	)
IDENT	IF
(	(
IDENT	LSIDE
)	)
IDENT	THEN
IDENT	NROWA
=	=
IDENT	M
IDENT	ELSE
IDENT	NROWA
=	=
IDENT	N
IDENT	END
IDENT	IF
IDENT	NOUNIT
=	=
IDENT	LSAME
(	(
IDENT	DIAG
,	,
STRING	'N'
)	)
IDENT	UPPER
=	=
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'U'
)	)
COMMENT	*
IDENT	INFO
=	=
IDENT	0
IDENT	IF
(	(
(	(
.	.
IDENT	NOT
.	.
IDENT	LSIDE
)	)
.	.
IDENT	AND
.	.
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	SIDE
,	,
STRING	'R'
)	)
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	1
IDENT	ELSE
IDENT	IF
(	(
(	(
.	.
IDENT	NOT
.	.
IDENT	UPPER
)	)
.	.
IDENT	AND
.	.
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'L'
)	)
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	2
IDENT	ELSE
IDENT	IF
(	(
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	TRANSA
,	,
STRING	'N'
)	)
)	)
.	.
IDENT	AND
.	.
+	+
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	TRANSA
,	,
STRING	'T'
)	)
)	)
.	.
IDENT	AND
.	.
+	+
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	TRANSA
,	,
STRING	'C'
)	)
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	3
IDENT	ELSE
IDENT	IF
(	(
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	DIAG
,	,
STRING	'U'
)	)
)	)
.	.
IDENT	AND
.	.
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	DIAG
,	,
STRING	'N'
)	)
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	4
IDENT	ELSE
IDENT	IF
(	(
IDENT	M
.	.
IDENT	LT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	5
IDENT	ELSE
IDENT	IF
(	(
IDENT	N
.	.
IDENT	LT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	6
IDENT	ELSE
IDENT	IF
(	(
IDENT	LDA
.	.
IDENT	LT
.	.
IDENT	MAX
(	(
IDENT	1
,	,
IDENT	NROWA
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	9
IDENT	ELSE
IDENT	IF
(	(
IDENT	LDB
.	.
IDENT	LT
.	.
IDENT	MAX
(	(
IDENT	1
,	,
IDENT	M
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	11
IDENT	END
IDENT	IF
IDENT	IF
(	(
IDENT	INFO
.	.
IDENT	NE
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	CALL
IDENT	XERBLA
(	(
STRING	'DTRSM '
,	,
IDENT	INFO
)	)
IDENT	RETURN
IDENT	END
IDENT	IF
COMMENT	*
COMMENT	*     Quick return if possible.
COMMENT	*
IDENT	IF
(	(
IDENT	M
.	.
IDENT	EQ
.	.
IDENT	0
.	.
IDENT	OR
.	.
IDENT	N
.	.
IDENT	EQ
.	.
IDENT	0
)	)
IDENT	RETURN
COMMENT	*
COMMENT	*     And when  alpha.eq.zero.
COMMENT	*
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	EQ
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	DO
IDENT	20
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	DO
IDENT	10
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	ZERO
IDENT	10
IDENT	CONTINUE
IDENT	20
IDENT	CONTINUE
IDENT	RETURN
IDENT	END
IDENT	IF
COMMENT	*
COMMENT	*     Start the operations.
COMMENT	*
IDENT	IF
(	(
IDENT	LSIDE
)	)
IDENT	THEN
IDENT	IF
(	(
IDENT	LSAME
(	(
IDENT	TRANSA
,	,
STRING	'N'
)	)
)	)
IDENT	THEN
COMMENT	*
COMMENT	*           Form  B := alpha*inv( A )*B.
COMMENT	*
IDENT	IF
(	(
IDENT	UPPER
)	)
IDENT	THEN
IDENT	DO
IDENT	60
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	30
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	30
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	50
IDENT	K
=	=
IDENT	M
,	,
IDENT	1
,	,
-	-
IDENT	1
IDENT	IF
(	(
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
/	/
IDENT	A
(	(
IDENT	K
,	,
IDENT	K
)	)
IDENT	DO
IDENT	40
IDENT	I
=	=
IDENT	1
,	,
IDENT	K
-	-
IDENT	1
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
*	*A
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	40
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	50
IDENT	CONTINUE
IDENT	60
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	100
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	70
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	70
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	90
IDENT	K
=	=
IDENT	1
,	,
IDENT	M
IDENT	IF
(	(
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
/	/
IDENT	A
(	(
IDENT	K
,	,
IDENT	K
)	)
IDENT	DO
IDENT	80
IDENT	I
=	=
IDENT	K
+	+
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	B
(	(
IDENT	K
,	,
IDENT	J
)	)
*	*A
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	80
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	90
IDENT	CONTINUE
IDENT	100
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	ELSE
COMMENT	*
COMMENT	*           Form  B := alpha*inv( A**T )*B.
COMMENT	*
IDENT	IF
(	(
IDENT	UPPER
)	)
IDENT	THEN
IDENT	DO
IDENT	130
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	DO
IDENT	120
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	TEMP
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	DO
IDENT	110
IDENT	K
=	=
IDENT	1
,	,
IDENT	I
-	-
IDENT	1
IDENT	TEMP
=	=
IDENT	TEMP
-	-
IDENT	A
(	(
IDENT	K
,	,
IDENT	I
)	)
*	*B
(	(
IDENT	K
,	,
IDENT	J
)	)
IDENT	110
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	TEMP
=	=
IDENT	TEMP
/	/
IDENT	A
(	(
IDENT	I
,	,
IDENT	I
)	)
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	TEMP
IDENT	120
IDENT	CONTINUE
IDENT	130
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	160
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	DO
IDENT	150
IDENT	I
=	=
IDENT	M
,	,
IDENT	1
,	,
-	-
IDENT	1
IDENT	TEMP
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	DO
IDENT	140
IDENT	K
=	=
IDENT	I
+	+
IDENT	1
,	,
IDENT	M
IDENT	TEMP
=	=
IDENT	TEMP
-	-
IDENT	A
(	(
IDENT	K
,	,
IDENT	I
)	)
*	*B
(	(
IDENT	K
,	,
IDENT	J
)	)
IDENT	140
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	TEMP
=	=
IDENT	TEMP
/	/
IDENT	A
(	(
IDENT	I
,	,
IDENT	I
)	)
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	TEMP
IDENT	150
IDENT	CONTINUE
IDENT	160
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	END
IDENT	IF
IDENT	ELSE
IDENT	IF
(	(
IDENT	LSAME
(	(
IDENT	TRANSA
,	,
STRING	'N'
)	)
)	)
IDENT	THEN
COMMENT	*
COMMENT	*           Form  B := alpha*B*inv( A ).
COMMENT	*
IDENT	IF
(	(
IDENT	UPPER
)	)
IDENT	THEN
IDENT	DO
IDENT	210
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	170
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	170
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	190
IDENT	K
=	=
IDENT	1
,	,
IDENT	J
-	-
IDENT	1
IDENT	IF
(	(
IDENT	A
(	(
IDENT	K
,	,
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	DO
IDENT	180
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	A
(	(
IDENT	K
,	,
IDENT	J
)	)
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	180
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	190
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ONE
/	/
IDENT	A
(	(
IDENT	J
,	,
IDENT	J
)	)
IDENT	DO
IDENT	200
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	200
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	210
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	260
IDENT	J
=	=
IDENT	N
,	,
IDENT	1
,	,
-	-
IDENT	1
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	220
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	220
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	240
IDENT	K
=	=
IDENT	J
+	+
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	A
(	(
IDENT	K
,	,
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	DO
IDENT	230
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	A
(	(
IDENT	K
,	,
IDENT	J
)	)
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	230
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	240
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ONE
/	/
IDENT	A
(	(
IDENT	J
,	,
IDENT	J
)	)
IDENT	DO
IDENT	250
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	J
)	)
IDENT	250
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	260
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	ELSE
COMMENT	*
COMMENT	*           Form  B := alpha*B*inv( A**T ).
COMMENT	*
IDENT	IF
(	(
IDENT	UPPER
)	)
IDENT	THEN
IDENT	DO
IDENT	310
IDENT	K
=	=
IDENT	N
,	,
IDENT	1
,	,
-	-
IDENT	1
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ONE
/	/
IDENT	A
(	(
IDENT	K
,	,
IDENT	K
)	)
IDENT	DO
IDENT	270
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	K
)	)
=	=
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	270
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	290
IDENT	J
=	=
IDENT	1
,	,
IDENT	K
-	-
IDENT	1
IDENT	IF
(	(
IDENT	A
(	(
IDENT	J
,	,
IDENT	K
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	A
(	(
IDENT	J
,	,
IDENT	K
)	)
IDENT	DO
IDENT	280
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	280
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	290
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	300
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	K
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	300
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	310
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	360
IDENT	K
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	NOUNIT
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ONE
/	/
IDENT	A
(	(
IDENT	K
,	,
IDENT	K
)	)
IDENT	DO
IDENT	320
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	K
)	)
=	=
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	320
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	DO
IDENT	340
IDENT	J
=	=
IDENT	K
+	+
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
IDENT	A
(	(
IDENT	J
,	,
IDENT	K
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	A
(	(
IDENT	J
,	,
IDENT	K
)	)
IDENT	DO
IDENT	330
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
=	=
IDENT	B
(	(
IDENT	I
,	,
IDENT	J
)	)
-	-
IDENT	TEMP
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	330
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	340
IDENT	CONTINUE
IDENT	IF
(	(
IDENT	ALPHA
.	.
IDENT	NE
.	.
IDENT	ONE
)	)
IDENT	THEN
IDENT	DO
IDENT	350
IDENT	I
=	=
IDENT	1
,	,
IDENT	M
IDENT	B
(	(
IDENT	I
,	,
IDENT	K
)	)
=	=
IDENT	ALPHA
*	*B
(	(
IDENT	I
,	,
IDENT	K
)	)
IDENT	350
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	360
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	END
IDENT	IF
IDENT	END
IDENT	IF
COMMENT	*
IDENT	RETURN
COMMENT	*
COMMENT	*     End of DTRSM .
COMMENT	*
IDENT	END
