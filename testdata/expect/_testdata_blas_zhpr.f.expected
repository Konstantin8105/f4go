COMMENT	> \brief \b ZHPR
COMMENT	*
COMMENT	*  =========== DOCUMENTATION ===========
COMMENT	*
COMMENT	* Online html documentation available at
COMMENT	*            http://www.netlib.org/lapack/explore-html/
COMMENT	*
COMMENT	*  Definition:
COMMENT	*  ===========
COMMENT	*
COMMENT	*       SUBROUTINE ZHPR(UPLO,N,ALPHA,X,INCX,AP)
COMMENT	*
COMMENT	*       .. Scalar Arguments ..
COMMENT	*       DOUBLE PRECISION ALPHA
COMMENT	*       INTEGER INCX,N
COMMENT	*       CHARACTER UPLO
COMMENT	*       ..
COMMENT	*       .. Array Arguments ..
COMMENT	*       COMPLEX*16 AP(*),X(*)
COMMENT	*       ..
COMMENT	*
COMMENT	*
COMMENT	*> \par Purpose:
COMMENT	*  =============
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*> ZHPR    performs the hermitian rank 1 operation
COMMENT	*>
COMMENT	*>    A := alpha*x*x**H + A,
COMMENT	*>
COMMENT	*> where alpha is a real scalar, x is an n element vector and A is an
COMMENT	*> n by n hermitian matrix, supplied in packed form.
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Arguments:
COMMENT	*  ==========
COMMENT	*
COMMENT	*> \param[in] UPLO
COMMENT	*> \verbatim
COMMENT	*>          UPLO is CHARACTER*1
COMMENT	*>           On entry, UPLO specifies whether the upper or lower
COMMENT	*>           triangular part of the matrix A is supplied in the packed
COMMENT	*>           array AP as follows:
COMMENT	*>
COMMENT	*>              UPLO = 'U' or 'u'   The upper triangular part of A is
COMMENT	*>                                  supplied in AP.
COMMENT	*>
COMMENT	*>              UPLO = 'L' or 'l'   The lower triangular part of A is
COMMENT	*>                                  supplied in AP.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] N
COMMENT	*> \verbatim
COMMENT	*>          N is INTEGER
COMMENT	*>           On entry, N specifies the order of the matrix A.
COMMENT	*>           N must be at least zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] ALPHA
COMMENT	*> \verbatim
COMMENT	*>          ALPHA is DOUBLE PRECISION.
COMMENT	*>           On entry, ALPHA specifies the scalar alpha.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] X
COMMENT	*> \verbatim
COMMENT	*>          X is COMPLEX*16 array, dimension at least
COMMENT	*>           ( 1 + ( n - 1 )*abs( INCX ) ).
COMMENT	*>           Before entry, the incremented array X must contain the n
COMMENT	*>           element vector x.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] INCX
COMMENT	*> \verbatim
COMMENT	*>          INCX is INTEGER
COMMENT	*>           On entry, INCX specifies the increment for the elements of
COMMENT	*>           X. INCX must not be zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in,out] AP
COMMENT	*> \verbatim
COMMENT	*>          AP is COMPLEX*16 array, dimension at least
COMMENT	*>           ( ( n*( n + 1 ) )/2 ).
COMMENT	*>           Before entry with  UPLO = 'U' or 'u', the array AP must
COMMENT	*>           contain the upper triangular part of the hermitian matrix
COMMENT	*>           packed sequentially, column by column, so that AP( 1 )
COMMENT	*>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
COMMENT	*>           and a( 2, 2 ) respectively, and so on. On exit, the array
COMMENT	*>           AP is overwritten by the upper triangular part of the
COMMENT	*>           updated matrix.
COMMENT	*>           Before entry with UPLO = 'L' or 'l', the array AP must
COMMENT	*>           contain the lower triangular part of the hermitian matrix
COMMENT	*>           packed sequentially, column by column, so that AP( 1 )
COMMENT	*>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
COMMENT	*>           and a( 3, 1 ) respectively, and so on. On exit, the array
COMMENT	*>           AP is overwritten by the lower triangular part of the
COMMENT	*>           updated matrix.
COMMENT	*>           Note that the imaginary parts of the diagonal elements need
COMMENT	*>           not be set, they are assumed to be zero, and on exit they
COMMENT	*>           are set to zero.
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Authors:
COMMENT	*  ========
COMMENT	*
COMMENT	*> \author Univ. of Tennessee
COMMENT	*> \author Univ. of California Berkeley
COMMENT	*> \author Univ. of Colorado Denver
COMMENT	*> \author NAG Ltd.
COMMENT	*
COMMENT	*> \date December 2016
COMMENT	*
COMMENT	*> \ingroup complex16_blas_level2
COMMENT	*
COMMENT	*> \par Further Details:
COMMENT	*  =====================
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*>  Level 2 Blas routine.
COMMENT	*>
COMMENT	*>  -- Written on 22-October-1986.
COMMENT	*>     Jack Dongarra, Argonne National Lab.
COMMENT	*>     Jeremy Du Croz, Nag Central Office.
COMMENT	*>     Sven Hammarling, Nag Central Office.
COMMENT	*>     Richard Hanson, Sandia National Labs.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*  =====================================================================
token(96)	SUBROUTINE
IDENT	ZHPR
(	(
IDENT	UPLO
,	,
IDENT	N
,	,
IDENT	ALPHA
,	,
IDENT	X
,	,
IDENT	INCX
,	,
IDENT	AP
)	)
COMMENT	*
COMMENT	*  -- Reference BLAS level2 routine (version 3.7.0) --
COMMENT	*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
COMMENT	*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
COMMENT	*     December 2016
COMMENT	*
COMMENT	*     .. Scalar Arguments ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	ALPHA
token(98)	INTEGER
IDENT	INCX
,	,
IDENT	N
IDENT	CHARACTER
IDENT	UPLO
COMMENT	*     ..
COMMENT	*     .. Array Arguments ..
IDENT	COMPLEX
*	*1
IDENT	6
IDENT	AP
(	(
*	*)
,	,
IDENT	X
(	(
*	*)
COMMENT	*     ..
COMMENT	*
COMMENT	*  =====================================================================
COMMENT	*
COMMENT	*     .. Parameters ..
IDENT	COMPLEX
*	*1
IDENT	6
IDENT	ZERO
IDENT	PARAMETER
(	(
IDENT	ZERO
=	=
(	(
IDENT	0
.	.
IDENT	0
IDENT	D
+	+
IDENT	0
,	,
IDENT	0
.	.
IDENT	0
IDENT	D
+	+
IDENT	0
)	)
)	)
COMMENT	*     ..
COMMENT	*     .. Local Scalars ..
IDENT	COMPLEX
*	*1
IDENT	6
IDENT	TEMP
token(98)	INTEGER
IDENT	I
,	,
IDENT	INFO
,	,
IDENT	IX
,	,
IDENT	J
,	,
IDENT	JX
,	,
IDENT	K
,	,
IDENT	KK
,	,
IDENT	KX
COMMENT	*     ..
COMMENT	*     .. External Functions ..
IDENT	LOGICAL
IDENT	LSAME
IDENT	EXTERNAL
IDENT	LSAME
COMMENT	*     ..
COMMENT	*     .. External Subroutines ..
IDENT	EXTERNAL
IDENT	XERBLA
COMMENT	*     ..
COMMENT	*     .. Intrinsic Functions ..
IDENT	INTRINSIC
IDENT	DBLE
,	,
IDENT	DCONJG
COMMENT	*     ..
COMMENT	*
COMMENT	*     Test the input parameters.
COMMENT	*
IDENT	INFO
=	=
IDENT	0
if	IF
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'U'
)	)
.	.
IDENT	AND
.	.
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'L'
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	1
IDENT	ELSE
if	IF
(	(
IDENT	N
.	.
IDENT	LT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	2
IDENT	ELSE
if	IF
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	5
IDENT	END
if	IF
if	IF
(	(
IDENT	INFO
.	.
IDENT	NE
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	CALL
IDENT	XERBLA
(	(
STRING	'ZHPR  '
,	,
IDENT	INFO
)	)
IDENT	RETURN
IDENT	END
if	IF
COMMENT	*
COMMENT	*     Quick return if possible.
COMMENT	*
if	IF
(	(
(	(
IDENT	N
.	.
IDENT	EQ
.	.
IDENT	0
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	ALPHA
.	.
IDENT	EQ
.	.
IDENT	DBLE
(	(
IDENT	ZERO
)	)
)	)
)	)
IDENT	RETURN
COMMENT	*
COMMENT	*     Set the start point in X if the increment is not unity.
COMMENT	*
if	IF
(	(
IDENT	INCX
.	.
IDENT	LE
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	KX
=	=
IDENT	1
-	-
(	(
IDENT	N
-	-
IDENT	1
)	)
*	*I
IDENT	NCX
IDENT	ELSE
if	IF
(	(
IDENT	INCX
.	.
IDENT	NE
.	.
IDENT	1
)	)
IDENT	THEN
IDENT	KX
=	=
IDENT	1
IDENT	END
if	IF
COMMENT	*
COMMENT	*     Start the operations. In this version the elements of the array AP
COMMENT	*     are accessed sequentially with one pass through AP.
COMMENT	*
IDENT	KK
=	=
IDENT	1
if	IF
(	(
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'U'
)	)
)	)
IDENT	THEN
COMMENT	*
COMMENT	*        Form  A  when upper triangle is stored in AP.
COMMENT	*
if	IF
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	1
)	)
IDENT	THEN
IDENT	DO
IDENT	20
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
if	IF
(	(
IDENT	X
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ALPHA
*	*D
IDENT	CONJG
(	(
IDENT	X
(	(
IDENT	J
)	)
)	)
IDENT	K
=	=
IDENT	KK
IDENT	DO
IDENT	10
IDENT	I
=	=
IDENT	1
,	,
IDENT	J
-	-
IDENT	1
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	I
)	)
*	*T
IDENT	EMP
IDENT	K
=	=
IDENT	K
+	+
IDENT	1
IDENT	10
IDENT	CONTINUE
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
)	)
+	+
IDENT	DBLE
(	(
IDENT	X
(	(
IDENT	J
)	)
*	*T
IDENT	EMP
)	)
IDENT	ELSE
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
)	)
IDENT	END
if	IF
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	J
IDENT	20
IDENT	CONTINUE
IDENT	ELSE
IDENT	JX
=	=
IDENT	KX
IDENT	DO
IDENT	40
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
if	IF
(	(
IDENT	X
(	(
IDENT	JX
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ALPHA
*	*D
IDENT	CONJG
(	(
IDENT	X
(	(
IDENT	JX
)	)
)	)
IDENT	IX
=	=
IDENT	KX
IDENT	DO
IDENT	30
IDENT	K
=	=
IDENT	KK
,	,
IDENT	KK
+	+
IDENT	J
-	-
IDENT	2
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	IX
)	)
*	*T
IDENT	EMP
IDENT	IX
=	=
IDENT	IX
+	+
IDENT	INCX
IDENT	30
IDENT	CONTINUE
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
)	)
+	+
IDENT	DBLE
(	(
IDENT	X
(	(
IDENT	JX
)	)
*	*T
IDENT	EMP
)	)
IDENT	ELSE
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
)	)
)	)
IDENT	END
if	IF
IDENT	JX
=	=
IDENT	JX
+	+
IDENT	INCX
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	J
IDENT	40
IDENT	CONTINUE
IDENT	END
if	IF
IDENT	ELSE
COMMENT	*
COMMENT	*        Form  A  when lower triangle is stored in AP.
COMMENT	*
if	IF
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	1
)	)
IDENT	THEN
IDENT	DO
IDENT	60
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
if	IF
(	(
IDENT	X
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ALPHA
*	*D
IDENT	CONJG
(	(
IDENT	X
(	(
IDENT	J
)	)
)	)
IDENT	AP
(	(
IDENT	KK
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
)	)
)	)
+	+
IDENT	DBLE
(	(
IDENT	TEMP
*	*X
(	(
IDENT	J
)	)
)	)
IDENT	K
=	=
IDENT	KK
+	+
IDENT	1
IDENT	DO
IDENT	50
IDENT	I
=	=
IDENT	J
+	+
IDENT	1
,	,
IDENT	N
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	I
)	)
*	*T
IDENT	EMP
IDENT	K
=	=
IDENT	K
+	+
IDENT	1
IDENT	50
IDENT	CONTINUE
IDENT	ELSE
IDENT	AP
(	(
IDENT	KK
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
)	)
)	)
IDENT	END
if	IF
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
+	+
IDENT	1
IDENT	60
IDENT	CONTINUE
IDENT	ELSE
IDENT	JX
=	=
IDENT	KX
IDENT	DO
IDENT	80
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
if	IF
(	(
IDENT	X
(	(
IDENT	JX
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
IDENT	THEN
IDENT	TEMP
=	=
IDENT	ALPHA
*	*D
IDENT	CONJG
(	(
IDENT	X
(	(
IDENT	JX
)	)
)	)
IDENT	AP
(	(
IDENT	KK
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
)	)
)	)
+	+
IDENT	DBLE
(	(
IDENT	TEMP
*	*X
(	(
IDENT	JX
)	)
)	)
IDENT	IX
=	=
IDENT	JX
IDENT	DO
IDENT	70
IDENT	K
=	=
IDENT	KK
+	+
IDENT	1
,	,
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
IDENT	IX
=	=
IDENT	IX
+	+
IDENT	INCX
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	IX
)	)
*	*T
IDENT	EMP
IDENT	70
IDENT	CONTINUE
IDENT	ELSE
IDENT	AP
(	(
IDENT	KK
)	)
=	=
IDENT	DBLE
(	(
IDENT	AP
(	(
IDENT	KK
)	)
)	)
IDENT	END
if	IF
IDENT	JX
=	=
IDENT	JX
+	+
IDENT	INCX
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
+	+
IDENT	1
IDENT	80
IDENT	CONTINUE
IDENT	END
if	IF
IDENT	END
if	IF
COMMENT	*
IDENT	RETURN
COMMENT	*
COMMENT	*     End of ZHPR  .
COMMENT	*
IDENT	END
