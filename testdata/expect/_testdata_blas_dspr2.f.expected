COMMENT	> \brief \b DSPR2
COMMENT	*
COMMENT	*  =========== DOCUMENTATION ===========
COMMENT	*
COMMENT	* Online html documentation available at
COMMENT	*            http://www.netlib.org/lapack/explore-html/
COMMENT	*
COMMENT	*  Definition:
COMMENT	*  ===========
COMMENT	*
COMMENT	*       SUBROUTINE DSPR2(UPLO,N,ALPHA,X,INCX,Y,INCY,AP)
COMMENT	*
COMMENT	*       .. Scalar Arguments ..
COMMENT	*       DOUBLE PRECISION ALPHA
COMMENT	*       INTEGER INCX,INCY,N
COMMENT	*       CHARACTER UPLO
COMMENT	*       ..
COMMENT	*       .. Array Arguments ..
COMMENT	*       DOUBLE PRECISION AP(*),X(*),Y(*)
COMMENT	*       ..
COMMENT	*
COMMENT	*
COMMENT	*> \par Purpose:
COMMENT	*  =============
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*> DSPR2  performs the symmetric rank 2 operation
COMMENT	*>
COMMENT	*>    A := alpha*x*y**T + alpha*y*x**T + A,
COMMENT	*>
COMMENT	*> where alpha is a scalar, x and y are n element vectors and A is an
COMMENT	*> n by n symmetric matrix, supplied in packed form.
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Arguments:
COMMENT	*  ==========
COMMENT	*
COMMENT	*> \param[in] UPLO
COMMENT	*> \verbatim
COMMENT	*>          UPLO is CHARACTER*1
COMMENT	*>           On entry, UPLO specifies whether the upper or lower
COMMENT	*>           triangular part of the matrix A is supplied in the packed
COMMENT	*>           array AP as follows:
COMMENT	*>
COMMENT	*>              UPLO = 'U' or 'u'   The upper triangular part of A is
COMMENT	*>                                  supplied in AP.
COMMENT	*>
COMMENT	*>              UPLO = 'L' or 'l'   The lower triangular part of A is
COMMENT	*>                                  supplied in AP.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] N
COMMENT	*> \verbatim
COMMENT	*>          N is INTEGER
COMMENT	*>           On entry, N specifies the order of the matrix A.
COMMENT	*>           N must be at least zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] ALPHA
COMMENT	*> \verbatim
COMMENT	*>          ALPHA is DOUBLE PRECISION.
COMMENT	*>           On entry, ALPHA specifies the scalar alpha.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] X
COMMENT	*> \verbatim
COMMENT	*>          X is DOUBLE PRECISION array, dimension at least
COMMENT	*>           ( 1 + ( n - 1 )*abs( INCX ) ).
COMMENT	*>           Before entry, the incremented array X must contain the n
COMMENT	*>           element vector x.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] INCX
COMMENT	*> \verbatim
COMMENT	*>          INCX is INTEGER
COMMENT	*>           On entry, INCX specifies the increment for the elements of
COMMENT	*>           X. INCX must not be zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] Y
COMMENT	*> \verbatim
COMMENT	*>          Y is DOUBLE PRECISION array, dimension at least
COMMENT	*>           ( 1 + ( n - 1 )*abs( INCY ) ).
COMMENT	*>           Before entry, the incremented array Y must contain the n
COMMENT	*>           element vector y.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in] INCY
COMMENT	*> \verbatim
COMMENT	*>          INCY is INTEGER
COMMENT	*>           On entry, INCY specifies the increment for the elements of
COMMENT	*>           Y. INCY must not be zero.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*> \param[in,out] AP
COMMENT	*> \verbatim
COMMENT	*>          AP is DOUBLE PRECISION array, dimension at least
COMMENT	*>           ( ( n*( n + 1 ) )/2 ).
COMMENT	*>           Before entry with  UPLO = 'U' or 'u', the array AP must
COMMENT	*>           contain the upper triangular part of the symmetric matrix
COMMENT	*>           packed sequentially, column by column, so that AP( 1 )
COMMENT	*>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
COMMENT	*>           and a( 2, 2 ) respectively, and so on. On exit, the array
COMMENT	*>           AP is overwritten by the upper triangular part of the
COMMENT	*>           updated matrix.
COMMENT	*>           Before entry with UPLO = 'L' or 'l', the array AP must
COMMENT	*>           contain the lower triangular part of the symmetric matrix
COMMENT	*>           packed sequentially, column by column, so that AP( 1 )
COMMENT	*>           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
COMMENT	*>           and a( 3, 1 ) respectively, and so on. On exit, the array
COMMENT	*>           AP is overwritten by the lower triangular part of the
COMMENT	*>           updated matrix.
COMMENT	*> \endverbatim
COMMENT	*
COMMENT	*  Authors:
COMMENT	*  ========
COMMENT	*
COMMENT	*> \author Univ. of Tennessee
COMMENT	*> \author Univ. of California Berkeley
COMMENT	*> \author Univ. of Colorado Denver
COMMENT	*> \author NAG Ltd.
COMMENT	*
COMMENT	*> \date December 2016
COMMENT	*
COMMENT	*> \ingroup double_blas_level2
COMMENT	*
COMMENT	*> \par Further Details:
COMMENT	*  =====================
COMMENT	*>
COMMENT	*> \verbatim
COMMENT	*>
COMMENT	*>  Level 2 Blas routine.
COMMENT	*>
COMMENT	*>  -- Written on 22-October-1986.
COMMENT	*>     Jack Dongarra, Argonne National Lab.
COMMENT	*>     Jeremy Du Croz, Nag Central Office.
COMMENT	*>     Sven Hammarling, Nag Central Office.
COMMENT	*>     Richard Hanson, Sandia National Labs.
COMMENT	*> \endverbatim
COMMENT	*>
COMMENT	*  =====================================================================
token(96)	SUBROUTINE
IDENT	DSPR2
(	(
IDENT	UPLO
,	,
IDENT	N
,	,
IDENT	ALPHA
,	,
IDENT	X
,	,
IDENT	INCX
,	,
IDENT	Y
,	,
IDENT	INCY
,	,
IDENT	AP
)	)
COMMENT	*
COMMENT	*  -- Reference BLAS level2 routine (version 3.7.0) --
COMMENT	*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
COMMENT	*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
COMMENT	*     December 2016
COMMENT	*
COMMENT	*     .. Scalar Arguments ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	ALPHA
token(98)	INTEGER
IDENT	INCX
,	,
IDENT	INCY
,	,
IDENT	N
IDENT	CHARACTER
IDENT	UPLO
COMMENT	*     ..
COMMENT	*     .. Array Arguments ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	AP
(	(
*	*)
,	,
IDENT	X
(	(
*	*)
,	,
IDENT	Y
(	(
*	*)
COMMENT	*     ..
COMMENT	*
COMMENT	*  =====================================================================
COMMENT	*
COMMENT	*     .. Parameters ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	ZERO
IDENT	PARAMETER
(	(
IDENT	ZERO
=	=
IDENT	0
.	.
IDENT	0
IDENT	D
+	+
IDENT	0
)	)
COMMENT	*     ..
COMMENT	*     .. Local Scalars ..
IDENT	DOUBLE
IDENT	PRECISION
IDENT	TEMP1
,	,
IDENT	TEMP2
token(98)	INTEGER
IDENT	I
,	,
IDENT	INFO
,	,
IDENT	IX
,	,
IDENT	IY
,	,
IDENT	J
,	,
IDENT	JX
,	,
IDENT	JY
,	,
IDENT	K
,	,
IDENT	KK
,	,
IDENT	KX
,	,
IDENT	KY
COMMENT	*     ..
COMMENT	*     .. External Functions ..
IDENT	LOGICAL
IDENT	LSAME
IDENT	EXTERNAL
IDENT	LSAME
COMMENT	*     ..
COMMENT	*     .. External Subroutines ..
IDENT	EXTERNAL
IDENT	XERBLA
COMMENT	*     ..
COMMENT	*
COMMENT	*     Test the input parameters.
COMMENT	*
IDENT	INFO
=	=
IDENT	0
IDENT	IF
(	(
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'U'
)	)
.	.
IDENT	AND
.	.
.	.
IDENT	NOT
.	.
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'L'
)	)
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	1
IDENT	ELSE
IDENT	IF
(	(
IDENT	N
.	.
IDENT	LT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	2
IDENT	ELSE
IDENT	IF
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	5
IDENT	ELSE
IDENT	IF
(	(
IDENT	INCY
.	.
IDENT	EQ
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	INFO
=	=
IDENT	7
IDENT	END
IDENT	IF
IDENT	IF
(	(
IDENT	INFO
.	.
IDENT	NE
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	CALL
IDENT	XERBLA
(	(
STRING	'DSPR2 '
,	,
IDENT	INFO
)	)
IDENT	RETURN
IDENT	END
IDENT	IF
COMMENT	*
COMMENT	*     Quick return if possible.
COMMENT	*
IDENT	IF
(	(
(	(
IDENT	N
.	.
IDENT	EQ
.	.
IDENT	0
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	ALPHA
.	.
IDENT	EQ
.	.
IDENT	ZERO
)	)
)	)
IDENT	RETURN
COMMENT	*
COMMENT	*     Set up the start points in X and Y if the increments are not both
COMMENT	*     unity.
COMMENT	*
IDENT	IF
(	(
(	(
IDENT	INCX
.	.
IDENT	NE
.	.
IDENT	1
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	INCY
.	.
IDENT	NE
.	.
IDENT	1
)	)
)	)
IDENT	THEN
IDENT	IF
(	(
IDENT	INCX
.	.
IDENT	GT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	KX
=	=
IDENT	1
IDENT	ELSE
IDENT	KX
=	=
IDENT	1
-	-
(	(
IDENT	N
-	-
IDENT	1
)	)
*	*I
IDENT	NCX
IDENT	END
IDENT	IF
IDENT	IF
(	(
IDENT	INCY
.	.
IDENT	GT
.	.
IDENT	0
)	)
IDENT	THEN
IDENT	KY
=	=
IDENT	1
IDENT	ELSE
IDENT	KY
=	=
IDENT	1
-	-
(	(
IDENT	N
-	-
IDENT	1
)	)
*	*I
IDENT	NCY
IDENT	END
IDENT	IF
IDENT	JX
=	=
IDENT	KX
IDENT	JY
=	=
IDENT	KY
IDENT	END
IDENT	IF
COMMENT	*
COMMENT	*     Start the operations. In this version the elements of the array AP
COMMENT	*     are accessed sequentially with one pass through AP.
COMMENT	*
IDENT	KK
=	=
IDENT	1
IDENT	IF
(	(
IDENT	LSAME
(	(
IDENT	UPLO
,	,
STRING	'U'
)	)
)	)
IDENT	THEN
COMMENT	*
COMMENT	*        Form  A  when upper triangle is stored in AP.
COMMENT	*
IDENT	IF
(	(
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	1
)	)
.	.
IDENT	AND
.	.
(	(
IDENT	INCY
.	.
IDENT	EQ
.	.
IDENT	1
)	)
)	)
IDENT	THEN
IDENT	DO
IDENT	20
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
(	(
IDENT	X
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	Y
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
)	)
IDENT	THEN
IDENT	TEMP1
=	=
IDENT	ALPHA
*	*Y
(	(
IDENT	J
)	)
IDENT	TEMP2
=	=
IDENT	ALPHA
*	*X
(	(
IDENT	J
)	)
IDENT	K
=	=
IDENT	KK
IDENT	DO
IDENT	10
IDENT	I
=	=
IDENT	1
,	,
IDENT	J
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	I
)	)
*	*T
IDENT	EMP1
+	+
IDENT	Y
(	(
IDENT	I
)	)
*	*T
IDENT	EMP2
IDENT	K
=	=
IDENT	K
+	+
IDENT	1
IDENT	10
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	J
IDENT	20
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	40
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
(	(
IDENT	X
(	(
IDENT	JX
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	Y
(	(
IDENT	JY
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
)	)
IDENT	THEN
IDENT	TEMP1
=	=
IDENT	ALPHA
*	*Y
(	(
IDENT	JY
)	)
IDENT	TEMP2
=	=
IDENT	ALPHA
*	*X
(	(
IDENT	JX
)	)
IDENT	IX
=	=
IDENT	KX
IDENT	IY
=	=
IDENT	KY
IDENT	DO
IDENT	30
IDENT	K
=	=
IDENT	KK
,	,
IDENT	KK
+	+
IDENT	J
-	-
IDENT	1
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	IX
)	)
*	*T
IDENT	EMP1
+	+
IDENT	Y
(	(
IDENT	IY
)	)
*	*T
IDENT	EMP2
IDENT	IX
=	=
IDENT	IX
+	+
IDENT	INCX
IDENT	IY
=	=
IDENT	IY
+	+
IDENT	INCY
IDENT	30
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	JX
=	=
IDENT	JX
+	+
IDENT	INCX
IDENT	JY
=	=
IDENT	JY
+	+
IDENT	INCY
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	J
IDENT	40
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	ELSE
COMMENT	*
COMMENT	*        Form  A  when lower triangle is stored in AP.
COMMENT	*
IDENT	IF
(	(
(	(
IDENT	INCX
.	.
IDENT	EQ
.	.
IDENT	1
)	)
.	.
IDENT	AND
.	.
(	(
IDENT	INCY
.	.
IDENT	EQ
.	.
IDENT	1
)	)
)	)
IDENT	THEN
IDENT	DO
IDENT	60
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
(	(
IDENT	X
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	Y
(	(
IDENT	J
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
)	)
IDENT	THEN
IDENT	TEMP1
=	=
IDENT	ALPHA
*	*Y
(	(
IDENT	J
)	)
IDENT	TEMP2
=	=
IDENT	ALPHA
*	*X
(	(
IDENT	J
)	)
IDENT	K
=	=
IDENT	KK
IDENT	DO
IDENT	50
IDENT	I
=	=
IDENT	J
,	,
IDENT	N
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	I
)	)
*	*T
IDENT	EMP1
+	+
IDENT	Y
(	(
IDENT	I
)	)
*	*T
IDENT	EMP2
IDENT	K
=	=
IDENT	K
+	+
IDENT	1
IDENT	50
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
+	+
IDENT	1
IDENT	60
IDENT	CONTINUE
IDENT	ELSE
IDENT	DO
IDENT	80
IDENT	J
=	=
IDENT	1
,	,
IDENT	N
IDENT	IF
(	(
(	(
IDENT	X
(	(
IDENT	JX
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
.	.
IDENT	OR
.	.
(	(
IDENT	Y
(	(
IDENT	JY
)	)
.	.
IDENT	NE
.	.
IDENT	ZERO
)	)
)	)
IDENT	THEN
IDENT	TEMP1
=	=
IDENT	ALPHA
*	*Y
(	(
IDENT	JY
)	)
IDENT	TEMP2
=	=
IDENT	ALPHA
*	*X
(	(
IDENT	JX
)	)
IDENT	IX
=	=
IDENT	JX
IDENT	IY
=	=
IDENT	JY
IDENT	DO
IDENT	70
IDENT	K
=	=
IDENT	KK
,	,
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
IDENT	AP
(	(
IDENT	K
)	)
=	=
IDENT	AP
(	(
IDENT	K
)	)
+	+
IDENT	X
(	(
IDENT	IX
)	)
*	*T
IDENT	EMP1
+	+
IDENT	Y
(	(
IDENT	IY
)	)
*	*T
IDENT	EMP2
IDENT	IX
=	=
IDENT	IX
+	+
IDENT	INCX
IDENT	IY
=	=
IDENT	IY
+	+
IDENT	INCY
IDENT	70
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	JX
=	=
IDENT	JX
+	+
IDENT	INCX
IDENT	JY
=	=
IDENT	JY
+	+
IDENT	INCY
IDENT	KK
=	=
IDENT	KK
+	+
IDENT	N
-	-
IDENT	J
+	+
IDENT	1
IDENT	80
IDENT	CONTINUE
IDENT	END
IDENT	IF
IDENT	END
IDENT	IF
COMMENT	*
IDENT	RETURN
COMMENT	*
COMMENT	*     End of DSPR2 .
COMMENT	*
IDENT	END
